<DOC>
<DOCNO>EP-0635796</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Compactly encoded stored string set and its use
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1730	G06F1730	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F17	G06F17	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A product includes a storage medium and string set data stored by the storage 
medium. The string set data can be accessed in a search to determine whether a string of 

characters is one of a set of strings. The string set data includes items of data (ADDRESSES 1-6) 
ordered in a sequence. Some of the items of data include label information (LABEL), next 

information (EOB), and alternative information (ALT). The label information (LABEL) indicates 
a character type. The next information (EOB) indicates whether the item of data has a next 

data item to which search continues if a current character in the string is an instance of the 
character type indicated by the label information (LABEL). The alternative information (ALT) 

indicates whether the item of data has an alternative data item to which search can continue if 
the current character in the string is not an instance of the character type indicated by the label 

information (LABEL). The item of data is positioned so that, if the next information (EOB) 
indicates that the first data item has a next data item, the next data item can be accessed 

(258;Fig. 11) based on the positions in the sequence of the first and next (EOB) data items. The 
item of data also is positioned in the sequence so that, if the alternative information (ALT) 

indicates that the first data item has an alternative data item, the alternative data item can be 
accessed (266;Fig. 11) based on the positions in the sequence of the first and alternative data 

items. The item of data can also include final information (FINAL) indicating whether a string 
of characters being matched is in the set of strings if its last character matches the label 

information. The item of data can be encoded in a byte (88;Fig. 5) and the string set data can 
also include a pointer (234;Fig. 9) to the item of data to reduce redundancy. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
XEROX CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
XEROX CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
KAPLAN RONALD M
</INVENTOR-NAME>
<INVENTOR-NAME>
KAY MARTIN
</INVENTOR-NAME>
<INVENTOR-NAME>
MAXWELL III JOHN T
</INVENTOR-NAME>
<INVENTOR-NAME>
KAPLAN, RONALD M.
</INVENTOR-NAME>
<INVENTOR-NAME>
KAY, MARTIN
</INVENTOR-NAME>
<INVENTOR-NAME>
MAXWELL III, JOHN T.
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to data stored in a compactly encoded form.Lucchesi, C.L. and Kowaltowski, T., "Applications of Finite Automata Representing
Large Vocabularies," Softwareâ€•Practice and Experience, Vol. 23(1), January 1993, pp. 15-30,
describe techniques for compressing a very large vocabulary of words into a minimal acyclic
deterministic finite automaton, motivated by the problem of implementing an efficient
spelling checker. Fig. 4 shows such an automaton for all forms of certain English verbs. A
technique for constructing the automaton is described beginning on page 18; the technique
includes a minimization step. The data structure is described at pages 19-20: Each state is
represented as an array with N entries, where N is the size of the alphabet. Most entries
correspond to non-existent transitions, and state arrays can therefore be shifted and
overlapped in such a way that existing entries do not collide. To each state is attached one N-bit
vector that selects the existing transitions for the state. Array packing is done by a greedy
algorithm, which almost always gives optimal results due to a very large percentage of states
with one, two, or three transitions. Also, the number of distinct bit-vectors is much lower than
the number of states, so that many are shared. Besides packing the state arrays, short (relative)
and long (absolute) state indices are used. For Portugese, letters are stripped of their diacritical
marks, the positions of which are encoded after the word terminator.The present invention provides a product according to claim 1 of the appended
claims. The invention further provides a method of searching string set data according to claim
13 of the appended claims.The invention futher provides a programmable apparatus when suitably
programmed for carrying out the method of claim 13.The invention alleviates the problem of compactly storing data defining a set of
strings, such as words, numbers, and other strings that include alphabetical, phonetic,
ideographic, or pictographic elements; numerical elements such as numbers; punctuation
marks; diacritical marks; mathematical and logical symbols; and other discrete elements that
can appear in a written or printed form of a language, all of which are referred to herein as
"characters". The invention is based on the discovery of several related techniques that reduce
the amount of data necessary to represent a set of strings.A first technique uses the order of items of data to hold certain information that
would otherwise
</DESCRIPTION>
<CLAIMS>
A product for use in a machine that performs a search with a
string of characters, comprising:


a storage medium for storing data in machine-accessible form; and
string set data stored by the storage medium; the string set data
indicating a set of strings; the string set data comprising a sequence of data

items including a first data item; the first data item including;
first item label information indicating at least one of a set of character
types and first item search information that can be used in a machine search of

the sequence of data items with a string of characters;
the first item search information including;
first item next information indicating whether the first data item has a
next data item to which the machine search can continue if a current character

in the string matches the first item label information; the next data item being
accessible based on the position in the sequence of the first data item; and
first item alternative information indicating whether the first data item
has an alternative data item to which the machine search can continue if the

current character in the string does not match the first item label information;
the alternative data item being accessible based on the position in the sequence

of the first data item.
The product of claim 1, in which the first data item's next data
item immediately follows the first data item in the sequence.
The product of any of claims 1 or 2, in which the first data
item's alternative data item immediately follows a second data item in the

sequence; the first data item beginning a subsequence of data items that ends
with the second data item; the second data item not having a next data item; the

subsequence including a first number of data items that do not have next data
items and a second number of data items that have alternative data items; the

first and second numbers being equal. 
The product of any of the preceding claims, in which the first
data item includes only one byte; the one byte including the first item label

information and the first item search information.
The product of any of the preceding claims, in which the first
data item includes first and second bytes; the first byte including the first item

label information and the first item alternative information; the second byte
including the first item next information; the first item next information

indicating that the first data item does not have a next data item.
The product of any of the preceding claims, in which the first
data item further includes first item final information; the first item final

information indicating whether the string of characters is in the set of strings if
the last character in the string matches the first item label information.
The product of any of the preceding claims, in which the string
set data further comprise a pointer data item that includes pointer information

indicating the location of the first data item.
The product of claim 7, in which the pointer information further
indicates a number of following bytes; the pointer data item and the following

bytes together indicating the location of the first data item.
The product of claims 7 or 8, in which the string set data further
comprise a lookup table; the pointer information indicating an entry in the

lookup table; the entry indicated by the pointer information including a full
length location of the first data item.
The product of the preceding claims, in which the set of strings
includes words.
A system comprising the product of any preceding claim, the
system further comprising a processor connected for accessing the string set

data.
The system of claim 11, further comprising instruction data
stored by the storage medium, the instruction data indicating instructions the

processor can execute to perform a machine search of the string set data with 
a string of characters; the processor being connected for accessing the

instruction data.
A method of searching string set data with a string of characters;
the string set data indicating a set of strings; the string set data including a

sequence of data items including a first data item; the first data item including:

first item label information indicating at least one of a set of character
types and first item search information;
the first item search information including;
first item next information indicating whether the first data item has a
next data item; and
first item alternative information indicating whether the first data item
has an alternative data item;
the method comprising;
accessing the first data item;
if a current character int he string matches the first item label
information and the first item next information indicates that the first data item

has a next data item, accessing the next data item based on the position in the
sequence of the first data item; and
if a current character in the string does not match the first item label
information and the first item alternative information indicates that the first data

item has an alternative data item, accessing the alternative data item based on
the position in the sequence of the first data item.
</CLAIMS>
</TEXT>
</DOC>
