<DOC>
<DOCNO>EP-0628911</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Test program generator.
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F906	G06F906	G06F944	G06F944	G06F1122	G06F1122	G06F1136	G06F1136	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F9	G06F9	G06F9	G06F11	G06F11	G06F11	G06F11	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
An architecture-independent test program generator for producing 
test programs for checking the operation of a hardware processor design 

comprises means for storing data representing the processor instruction 
set and resources, and logic (30) for generating, for subsequent storage 

or processing, test programs from said stored data, characterised in that 
the data is a separate declarative specification (10), the generator 

comprising logic (50) for extracting said data from the storage means, 
and in that the relationships between the processor resources and 

semantic entities associated with each instruction are modelled in said 
declarative specification. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
IBM
</APPLICANT-NAME>
<APPLICANT-NAME>
INTERNATIONAL BUSINESS MACHINES CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
AHARON AHARON
</INVENTOR-NAME>
<INVENTOR-NAME>
LICHTENSTEIN YOSSI
</INVENTOR-NAME>
<INVENTOR-NAME>
MALKA YOSSI
</INVENTOR-NAME>
<INVENTOR-NAME>
AHARON, AHARON
</INVENTOR-NAME>
<INVENTOR-NAME>
LICHTENSTEIN, YOSSI
</INVENTOR-NAME>
<INVENTOR-NAME>
MALKA, YOSSI
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The invention relates to a test program generator for generating 
programs for use in checking hardware processor designs for computers. The goal of processor verification is to ensure equivalence of a 
processor and its architectural specification. This goal can be achieved 
either by a formal proof or by exhaustive simulation. However, the 
complexity of processors renders the formal approach impractical for most 
industrial applications and the size of the test space makes exhaustive 
simulation impossible. Typically, the architecture specification is an informal 
description of the processor's resources, the instruction repertoire and 
the effect of instruction execution on the processor state. It also 
describes the main hardware mechanisms such as address translation, 
interrupt handling or multi-tasking. Computer architectures are complex. 
A typical architecture includes hundreds of instructions; a few dozens of 
resources, such as main memory, general-purpose registers, 
special-purpose registers; and complex functional units, e.g. floating 
point, address translation, external interrupt mechanism. A typical 
architecture description is a few hundred pages long. In practice, design verification of hardware processors is 
generally, but not exclusively, carried out by simulating the operation 
of sets of assembly level test programs using a hardware simulator with a 
particular set of design parameters and comparing the results with the 
output predicted by a behavioural simulator. The hardware simulator may take as input a design model written in 
a hardware description language, such as the IEEE standard VHDL (IEEE 
standard 1076-1987). Of course, if prototype hardware is available the 
test programs may be run directly on that. The behavioural simulator is 
normally written for software development purposes prior to having the 
actual hardware and represents the expected behaviour of the hardware 
given the architecture specification. Traditionally, these test programs are written manually. First, a 
list of test requirements is compiled; then tests are written to cover 
this list. Requirements derived from the architecture specification  
 
usually call for the testing of every instruction, under normal, boundary 
and exception conditions. The tests written to satisfy these 
requirements are called Architecture Verification Programs (AVP), and are 
required to run correctly on any realization of the architecture. The 
design work-book, which defines major design details, such as clock cycle

</DESCRIPTION>
<CLAIMS>
A test program generator for producing test programs for checking 
the operation of a hardware processor design, comprising means for 

storing data representing the processor instruction set and resources, 
and logic (30) for generating, for subsequent storage or processing, test 

programs from said stored data, characterised in that the data is a 
separate declarative specification (10), the generator comprising logic 

(50) for extracting said data from the storage means, and in that the 
relationships between semantic entities associated with each instruction 

and/or between said semantic entities and the processor resources are 
modelled in said declarative specification. 
A test program generator as claimed in claim 1 wherein, in the 
separate declarative specification (10), the representation of each 

instruction is stored in the form of a tree structure, the first level of 
the tree comprising the syntax of the instruction and the last level of 

the tree comprising the possible values of and the relations between the 

semantic entities, the generator comprising means for generating 
instances of the instruction and means for traversing the tree structure 

in a depth first order and generating an instance of each semantic entity 
in accordance with the choices made at previous traversal steps and to 

keep the consistency of the instruction instances. 
A test program generator as claimed in claim 1 or claim 2 wherein 
testing knowledge relevant to the generation of useful test programs is 

modelled in the stored data. 
A test program generator as claimed in claim 3 as dependant on 
claim 2 wherein testing knowledge relevant to the generation of useful 

test programs is modelled procedurally in the stored data by the means 
for generating the semantic entity instances comprising generation 

functions, which generation functions are tailorable by the user so that 
desired types of test cases can be generated. 
A test program generator as claimed in claim 3 or claim 4 
comprising means for testing generated semantic entity instances in 

accordance with one or more validation criteria, the generation of the 
semantic entity instances being repeated if the generated instance does 

not satisfy the, or each, validation criteria. 
A test program generator as claimed in claim 5 wherein the 
validation criteria are tailorable by the user to prevent undesired types 

of test cases being generated. 
A test program generator as claimed in any preceding claim wherein 
the separate declarative specification (10) is a database external to the 

generating logic (30). 
A method for producing, for subsequent storage or processing, test 
programs for checking the operation of a hardware processor design, the 

method comprising: storing data representing the processor instruction 
set and resources in a separate declarative specification (10) in which 

declarative specification the relationships between semantic entities 
associated with each instruction and/or between said semantic entities 

and the processor resources are modelled; extracting said data from 
storage; and generating test programs from said extracted data. 
A method as claimed in claim 8 wherein, in the separate declarative 
specification (10), the representation of each instruction is stored in 

the form of a tree structure, the first level of the tree comprising the 
syntax of the instruction and the last level of the tree comprising the 

possible values of and the relations between the semantic entities, and 
the generation step comprises: generating instances of the instruction; 

traversing the tree structure in a depth first order and generating an 
instance of each semantic entity according to the choices made at 

previous traversal steps and to keep the consistency of the instruction 
instances. 
A method as claimed in claim 9 comprising storing generation 
functions, and wherein the step of generating the semantic entity 

instances is performed under the control of the generation functions, the 
generation functions being such that desired types of test cases are 

generated. 
</CLAIMS>
</TEXT>
</DOC>
