<DOC>
<DOCNO>EP-1221090</DOCNO> 
<TEXT>
<INVENTION-TITLE>
A METHOD FOR DESCRIBING SOFTWARE ARCHITECTURE
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F944	G06F944	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F9	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A method for describing software architecture utilizes a service concept to provide a map of the software system's features from top-level functionalities to actual code through all intermediate abstractions. The services are defined as logical and physical services. Physical services are bound to a given level of abstraction by the actual implementation, whereas logical services can be hierarchically divided into smaller logical services. A suitable abstraction level can be used for the logical services so that the best match between physical and logical services can be achieved. Linking physical services to logical services is done so that the set of physical services that implement a set of logical services can be found in a top-down fashion. Also the set of logical services that is implemented by a set of physical services can be found in the bottom-up fashion. The logical service structure can be used as a reference software architecture.
</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
NOKIA CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
NOKIA CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
LAHDE EERO
</INVENTOR-NAME>
<INVENTOR-NAME>
MIKKONEN TOMMI
</INVENTOR-NAME>
<INVENTOR-NAME>
NIEMI JUHAPEKKA
</INVENTOR-NAME>
<INVENTOR-NAME>
LAHDE, EERO
</INVENTOR-NAME>
<INVENTOR-NAME>
MIKKONEN, TOMMI
</INVENTOR-NAME>
<INVENTOR-NAME>
NIEMI, JUHAPEKKA
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
 A Method For Describing Software ArchitectureBACKGROUND OF THE INVENTION 1. Field of the InventionThe present invention relates to software architectures, and more particularly, it relates to a method for describing software system architecture in terms of services at different abstraction levels.2. Description of the Related ArtSoftware systems are generally made up of several different parts that interact with each other as required to perform a particular task. These different parts are referred to as parties or software (SW) artifacts that are generally designed together to make up the entire software architecture. The software architecture is formed with a hierarchy of SW artifacts that operate at different abstraction levels. The relationship between the system abstractions becomes an important factor when attempting to modify the software system to perform newly desired tasks.Each modification made to an existing software system results in the evolution of that software system into a more complex system. This is particularly the case when taking into consideration the conceptual abstractions that make up the system, and is primarily due to the fact that modifications to an existing system are seldom such that they cleanly fit into the scope of the originally included abstractions. Instead, existing abstractions are often compromised or invalidated in order to facilitate new requirements to which the system is to be subjected. This results in potential downgrading or decreased dependability of the software system. In addition, the rework needed for correcting 

the abstractions may not be an option due to the time schedule for implementing the modifications and returning the product to market (i.e., time-to-market) or lack of development resources. Additional difficulties may arise due to the fact that sometimes fundamental abstractions need to be sacrificed even at the very beginning of software system development as a result of performance requirements which, for example, may lead to tightly coupled applications and poorly defined abstractions even in the early phases of a products life.As the need for modifications, enhancements, or new features increases, the abstractions used as a basis for the software applications of the system usually become fragile. These abstractions are often augmented with extensions and exceptions that logically belong to the scope of some other abstraction (s) , but due to the performance or resourcing reasons, need to be implemented as a special case of a certain
</DESCRIPTION>
<CLAIMS>
CLAIMS
What is claimed is:
1. A method for describing software architecture comprising the steps of: identifying software artifacts that make up the software architecture; determining interfaces between the identified software artifacts; structuring the interfaces into dialogues; defining the dialogues; and documenting the purpose and usage of the dialogues as physical services.
2. The method set forth in claim 1, further comprising: determining interactions between applications within the software architecture; and generating conceptual definitions of the interactions as logical services; wherein said step of documenting utilizes the conceptual definitions of the interactions in conjunction with said defined dialogues to document the purpose and usage of the respective services.
3. The method set forth in claim 2, further comprising: mapping logical services to each physical service used in its implementation; determining whether said step of mapping generates a sufficiently simple map based on relationships between the logical and physical services; and documenting said map when it has been determined to be sufficiently simple. 

4. The method set forth in claim 3, further comprising decomposing the logical services into lower level logical services by dividing them into several interactions, said step of decomposing being performed when said map is determined to be insufficiently simple.
5. The method set forth in claim 3, wherein said step of determining returns a result of a sufficiently simple map when each logical service is implemented by as few physical services as possible and each physical service participates in as few logical services as possible.
6. The method set forth in claim 3, wherein said step of determining returns a result of an insufficiently simple map when each logical service is not implemented by as few physical services as possible.
7. The method set forth in claim 3, wherein said step of determining returns a result of an insufficiently simple map when each physical service does not participate in as few logical services as possible.
8. A method for describing software architecture for enabling efficient software development comprising the steps of: creating a service hierarchy having logical and physical services descriptive of the software architecture; mapping the created service hierarchy; identifying logical services to be modified using the created service hierarchy; 


 analyzing side effects to related services resulting from the modification of the identified logical services; identifying hot spots by evaluating the mapping of the created service hierarchy; and redesigning all software artifacts of the software architecture relating to the logical services to be modified.
9. The method set forth in claim 8, further comprising determining whether modifications to the software architecture are needed.
10. The method set forth in claim 8, wherein said step of analyzing comprises determining whether new side effects are found, and repeating said step of identifying logical services to be modified when new side effects have been found.
11. The method set forth in claim 8, wherein the side effects analyzed occur when a physical service participates in implementing several logical services and only some of the logical services to which it participates are being modified.
12. The method set forth in claim 8, further comprising: structuring a system documentation using the created service hierarchy and thereby enabling the creation of a system that is navigable between documentational elements 

</CLAIMS>
</TEXT>
</DOC>
