<DOC>
<DOCNO>EP-0611098</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Circular viterbi decoder for tail-biting convolutional codes.
</INVENTION-TITLE>
<CLASSIFICATIONS>H03M1300	H03M1323	H03M1341	H04L100	H04L100	H04L2508	H04L2508	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>H03M	H03M	H03M	H04L	H04L	H04L	H04L	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>H03M13	H03M13	H03M13	H04L1	H04L1	H04L25	H04L25	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A receiver for decoding 
N
 received branchword signals is disclosed. 
Illustratively, the branchword signals are generated by a tailbiting convolutional 

coder. The receiver stores received branchword signals in memory such that the 
branchword signals are accessible in a logically circular sequence. The receiver then 

performs Viterbi updates on the logically circular sequence of branchwords, the 
sequence comprising more than 
N
 branchwords. Each Viterbi update provides a 
decision vector. The receiver stops performing Viterbi updates in response to an 

indication that Viterbi update decisions have become repetitive. A set of generated 
decision vectors resulting from the Viterbi updates is then modified in response to 

the indication. A decoded signal is generated by performing a Viterbi traceback 
procedure using the modified set of decision vectors. The indication that Viterbi 

update decisions have become repetitive may be provided by a predetermined fixed 
number of Viterbi updates, the number reflecting an estimate of when said update 

decisions will likely become repetitive. The indication may also be provided by a 
comparison of decision vectors generated by Viterbi updates on the same stored 

branchword to determine whether the vectors are substantially equal. Or, the 
indication may be provided by a comparison of a pair of path metric vectors 

generated by Viterbi updates on the same stored branchword to determine whether 
differences between metric signals of one or more respective trellis state pairs of the 

path metric vectors are substantially equal. Modification of the set of generated 
decision vectors may include replacing a one or more decision vectors of the set with 

one or more later-determined decision vectors of the set. Alternatively, such 
modification may include extending the set of decision vectors by
 repeating 
previously determined decision vectors of the set. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
AT 
&
 T CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
AT 
&
 T CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
AT 
&
 T CORP
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
COX RICHARD VANDERVOORT
</INVENTOR-NAME>
<INVENTOR-NAME>
SUNDBERG CARL-ERIK WILHELM
</INVENTOR-NAME>
<INVENTOR-NAME>
COX RICHARD VANDERVOORT
</INVENTOR-NAME>
<INVENTOR-NAME>
SUNDBERG CARL-ERIK WILHELM
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
This invention relates to decoding of channel codes such as tailbiting 
convolutional codes. When information signals are communicated from a transmitter to a 
receiver via a communication channel, such information signals may be corrupted by 
noise associated with the channel. To help prevent such noise from corrupting the 
received information, a channel coding technique may be employed. Generally, 
coding which helps mitigate the effects of channel noise does so by introducing 
redundancy to the information to be communicated. Because of this redundancy, the 
likelihood that noise will corrupt communicated information is reduced. Convolutional codes are a class of channel codes used to mitigate the 
effects of channel noise in the transmission of information. Convolutional codes are 
well known in the art and have been adopted as standards for certain types of 
communication systems. One example of such a standard is IS-54 -- a standard for 
North American digital cellular radio. IS-54 employs a type of convolutional code 
known in the art as a tailbiting convolutional code. With tailbiting convolutional codes, a frame or block of information is 
encoded and communicated in a blockwise manner. The term "tailbiting" is used to 
refer to the fact that the coder begins and ends in the same coder state. The decoder 
is aware that the coder begins and ends in the same state, but is unaware of the value 
(or identity) of that state. The maximum-likelihood decoder for the convolutional codes is known 
in the art as the Viterbi decoder. As is well known, the Viterbi decoder treats the 
problem of decoding a sequence of received symbols as a problem of finding the 
most likely sequence of uncorrupted symbols given an actual corrupted sequence 
received. The maximum-likelihood decoder for tailbiting convolutional codes 
employs Viterbi decoding, but can place great demands on computational resources. 
This is due to the fact that the decoder is unaware of the coder's starting state and 
must perform Viterbi decoding exhaustively for all possible starting states. As a 
result, suboptimal decoding techniques for tailbiting convolutional codes providing 
good levels of error protection with less computational burden are desirable.  The present invention provides a method and apparatus for decoding 
convolutional codes, such as tailbiting convolutional codes. Illustratively, a receiver 
embodiment of the invention receives a signal reflecting N branchwords, c(m), 
1≦m≦N, to decode. These branchwords comprise n
</DESCRIPTION>
<CLAIMS>
A method of operating a receiver to decode N received branchword 
signals, c(j), 1≦j≦N, the method comprising the steps of: 


a. storing the received branchword signals in memory such that said signals 
are accessible in a logically circular sequence; 
b. performing Viterbi updates on a logically circular sequence of 
branchwords, the sequence comprising more than N branchwords, the Viterbi 

updates generating a set of decision vectors; 
c. stopping the performance of said Viterbi updates responsive to an 
indication that Viterbi update decisions have become repetitive; 
d. modifying the set of generated decision vectors responsive to said 
indication; and 
e. generating a decoded signal by performing a Viterbi traceback procedure 
using the modified set of decision vectors. 
The method of claim 1 wherein the code is a convolutional code. 
The method of claim 2 wherein the convolutional code is a tailbiting 
convolutional code. 
The method of claim 1 wherein the indication that Viterbi update 
decisions have become repetitive comprises a predetermined fixed number of Viterbi 

updates, said number reflecting an estimate of when said update decisions will likely 
become repetitive. 
The method of claim 1 wherein the indication that Viterbi update 
decisions have become repetitive is provided by comparing decision vectors 

generated by Viterbi updates on the same stored branchword to determine whether 
said vectors are substantially equal. 
The method of claim 1 wherein each Viterbi update further provides a 
vector of path metric signals, the vector including a path metric signal for each of a 

plurality of trellis states, and wherein the indication of repetitive Viterbi update 
decisions is based on the step of comparing a pair of path metric vectors generated 

by Viterbi updates on the same stored branchword to determine whether differences 
between metric signals of one or more respective trellis state pairs of said path 

metric vectors are substantially equal. 
The method of claim 6 wherein the indication that Viterbi update 

decisions have become repetitive is further based on the step of comparing decision 
vectors generated by Viterbi updates on the same stored branchword to determine 

whether said vectors are equal. 
The method of claim 1 wherein the step of modifying the set of 
generated decision vectors comprises the step of replacing a one or more decision 

vectors of the set with one or more later- determined decision vectors of the set. 
The method of claim 1 wherein the step of modifying the set of 
generated decision vectors comprises the step of extending the set of decision 

vectors by repeating previously determined decision vectors of the set. 
</CLAIMS>
</TEXT>
</DOC>
