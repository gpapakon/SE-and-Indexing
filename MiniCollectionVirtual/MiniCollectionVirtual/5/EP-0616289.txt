<DOC>
<DOCNO>EP-0616289</DOCNO> 
<TEXT>
<INVENTION-TITLE>
System and method for interactively formulating queries
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1200	G06F906	G06F1730	G06F1200	G06F1730	G06F906	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F12	G06F9	G06F17	G06F12	G06F17	G06F9	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
In a computerized database system, a query is formulated to 
retrieve data from the database by interactively identifying at least one 

table containing query data, and at least one column 
and at least one row in the identified table containing the query data. 

The rows are interactively identified using a condition statement. The 
condition statement is interactively formulated using at least one 

displayed flowline. Input is received from the user specifying a 
position on the flowline for insertion of a predicate and the predicate. 

The flowline is displayed with the predicate inserted in the specified 
location. The predicates are displayed on the flowline in between nodes. 

Predicates on the same flowline are combined through a logical AND 
operation. Predicates on different flowlines between the same nodes are 

combined through a logical OR operation. The flowline is converted to a 
corresponding Boolean algebra statement and displayed. Input from the 

user adding a predicate is received in the Boolean statement and is 
converted to a corresponding updated graphical flow representation. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
IBM
</APPLICANT-NAME>
<APPLICANT-NAME>
INTERNATIONAL BUSINESS MACHINES
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
JACOPI TOM WILLIAM
</INVENTOR-NAME>
<INVENTOR-NAME>
PAYTON BRIAN GERRIT
</INVENTOR-NAME>
<INVENTOR-NAME>
SIWEK HOWARD ALEXANDER
</INVENTOR-NAME>
<INVENTOR-NAME>
JACOPI, TOM WILLIAM
</INVENTOR-NAME>
<INVENTOR-NAME>
PAYTON, BRIAN GERRIT
</INVENTOR-NAME>
<INVENTOR-NAME>
SIWEK, HOWARD ALEXANDER
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to computerized relational database
informational retrieval systems, and more particularly relates to user
interfaces for retrieving data from relational databases.Computerized Database Management Systems (DBMSs) enable enterprises
to efficiently manage and access data. DBMSs store data electronically
in data storage devices such as direct access storage devices (DASD).
Computer programs run by a computer system provide access to the
database. The database user controls the computer processor and memory
from a terminal using interaction devices such as a keyboard or a mouse.The DBMS provides access to the database by logically controlling
the storage and retrieval of the data. A relational DBMS logically
stores the data organized into a plurality of tables consisting of a
plurality of rows and columns. Columns contain data of the same kind.
Rows contain different kinds of data about a single thing. The tables
and columns are assigned names through which a user can identify tables,
columns and rows for data retrieval.Data is retrievable from a relational database by a variety of
methods. A computer program can extract information from the database
without any human user intervention. Additionally, database users can
interact with the database using a query system program serving as an
access program to the database system.A common interface to a relational database is the Structured Query
Language (SQL). SQL queries identify the database, the columns and rows
for retrieval of the data. The columns are selected in the SQL SELECT
statement. The rows are determined by the condition statements in the
SQL SELECT statement WHERE clause. The condition statement identifies
rows as a function of at least one column of at least one table. For
example, an enterprise may have an employee database from which reports
are generated from time to time, such as a report on the names of
employees in a sales department who have been with the company for more
than 10 years. An SQL statement would be used to retrieve the data from
the employee database by retrieving all the employee names from a name
column of a database table where the corresponding column in the same row
for employee department has the value "sales" and the corresponding 
column in the same row for employment years has a value greater than 10.
The SQL statement would look like:
SELECT EMP.NAME
   FROM EMP_TABLEWHERE EMP.DEPT = "sales" and EMP.YEARS > 10.The foregoing SQL statement is a simplistic example of a query
statement
</DESCRIPTION>
<CLAIMS>
A method for interactively formulating queries for retrieving data
stored in tables having columns and rows in a computerized database

system having a central processing unit (CPU), memory, a display device,
and a user interaction device, the method comprising the steps of:


receiving input identifying at least one table containing the query
data;
receiving input identifying at least one column of the identified
table containing the query data;
receiving input identifying at least one row in the identified
table containing the query data using a condition statement and

characterised in that said condition statement is interactively
formulated by the steps of:


(a) displaying a graphical flow representation comprising at least one
flowline comprising at least one arc, a predicate assigned to each arc,

and a plurality of nodes, each arc positioned between a From_Node node
and a To_Node node, wherein predicates on the same flowline are combined

through a logical AND operation, and predicates on different flowlines
between the same nodes are combined through a logical OR operation;
(b) receiving input specifying a position on a flowline of the
graphical flow representation for insertion of a predicate;
(c) receiving input of the predicate;
(d) displaying the graphical flow representation with the predicate
inserted in the specified position;
(e) converting the graphical flow representation into a corresponding
Boolean algebra statement; and
(f) displaying the Boolean algebra statement.
A method as claimed in claim 1 further comprising the steps of:

receiving input from the user adding a predicate to a Boolean
algebra statement;
converting the Boolean algebra statement to a corresponding
graphical flow representation; and
displaying the graphical flow representation.
A method as claimed in claim 1 comprising the further steps for

converting a graph that is a graphical flow representation to a Boolean
algebra statement comprising the steps of: 


(a) compressing the graph to a minimum number of nodes and arcs by
combining 2 arcs and replacing said arcs with one single arc, to produce

a compressed graph, this combining of 2 arcs being achieved by

combining each pair of arcs having the same To_Nodes and From Nodes
into a resulting arc with the predicates assigned to the pair of arcs

connected by a logical OR operator assigned as a resulting predicate to
the resulting arc; and
combining each pair of arcs having the same To_Node of a first arc
and From_Node of a second arc into a resulting arc with the predicates

assigned to the pair of arcs connected by an AND operator assigned as a
resulting predicate to the resulting arc.; and
(b) creating a corresponding Boolean algebra string by identifying at
least one path through the compressed graph from a beginning node to an

ending node.
A method as claimed in claim 3 wherein the step of creating a
corresponding Boolean algebra string further comprises the steps of:


(a) pushing onto a stack a graph path;
(b) popping a path from the stack for further processing;
(c) processing the path to produce a Boolean algebra statement segment
while identifying any new paths;
(d) pushing a new path onto the stack; and
(e) repeating steps (b) through (d) until the stack is empty.
A method as claimed in claim 2 comprising the further steps for
converting a Boolean algebra statement representation to a graphical flow

representation of:

(a) arranging the Boolean algebra statement into a parse tree
comprising a plurality of elements including a root, each element being a

leaf or a non-leaf, each non-leaf having a left child and a right
child, and each element having a value assigned for a From_Node and a

To_Node, wherein each leaf is assigned a predicate and each non-leaf is
assigned an OR operator, or an AND operator; and
(b) processing each element of the tree in preorder traversal assigning
each predicate as an arc connecting a From_Node to a To_Node.
A method as claimed in claim 5 wherein the processing of each
element comprises the steps of:


assigning the root From_Node and To_Node a beginning node and an
ending node, respectively, of a resulting graph;
for each OR operator element, assigning the OR operator element
From_Node and To_Node as the From_Node and To_Node, respectively, of the

left child and right child of the OR operator element;
for each AND operator element:
creating a new node;
assigning the AND operator element From_Node as the From_Node of
the left child of the AND operator element;
assigning the new node as the To_Node of the left child and the
From_Node of the right child of the AND operator element; and
assigning the AND operator element To_Node as the To_Node of the
right child of the AND operator element; and
for each predicate element, creating an arc connecting the
From_Node to the To_Node of the predicate element and assigning the

predicate to the arc.
A method as claimed claim 1 further comprising the step of
interactively designating a section of the graphical flow representation

as having a logical NOT operation applied to the section.
A method for use in a computer system for converting a Boolean algebra statement representation
to a graphical representation comprising the steps of:


(a) arranging the Boolean statement into a parse tree wherein each
element in the parse tree has a tree From_Node and a tree To_Node and

each element is a leaf or a non-leaf, and each non-leaf has a left child
and a right child, wherein a leaf is a condition predicate and a non-leaf is an OR

operator or an AND operator; and
(b) processing each element of the tree in preorder traversal to assign
each condition predicate as a graph arc defined as connecting a graph

From_Node to a graph To_Node comprising the steps of:

assigning the root element From_Node and To_Node as the
Beginning_Node and Ending_Node of the graph;
for an OR operator element, assigning an OR operator element
From_Node and To_Node as the From_Node and To_Node of both of the OR

operator element children;
for an AND operator element, creating a New_Node assigning the AND
operator element From_Node as the From_Node of the left hand child of the

AND operator element, the AND operator element To_Node as the To_Node of
the right hand child of the AND operator element, assigning the New_Node

as the To_Node of the left hand child and the From_Node of the right hand
child of the AND operator element.
A method for use in a computer system for converting a graphical representation comprising a
plurality of nodes linked by arcs into a Boolean algebra statement

representation, comprising the steps of:

(a) when two arcs have the same To_Nodes and From_Nodes, combining the
arcs into one arc with the conditions represented by the original arcs

linked by a logical OR operand;
(b) when two arcs are in a series with a Third_Node in between having
the same two arcs going into and out of it, combining the arcs into one

arc with the conditions represented by each original arc linked by an AND
operator;
(c) pushing onto a stack a graph path;
(d) popping a path from the stack for further processing;
(e) processing the path to produce a Boolean algebra statement segment
while identifying any new paths;
(f) pushing a new path onto the stack; and
(g) repeating steps (d) through (f) until the stack is empty.
A computer system comprising: a central processing unit, a memory,
a display device, a user interaction device, and means configured to

carry out the steps of a method as claimed in any preceding claim.
</CLAIMS>
</TEXT>
</DOC>
