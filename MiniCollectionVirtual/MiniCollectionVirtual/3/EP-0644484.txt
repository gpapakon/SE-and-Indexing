<DOC>
<DOCNO>EP-0644484</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Data processing system and operating method
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F948	G06F946	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F9	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
An operating system combines preemptive scheduling 
with cooperative or non-preemptive scheduling. In particular, 

tasks are divided into groups of interdependent tasks. Each 
group includes tasks that should not be run asynchronously 

relative to each other. The scheduler in the operating system 
provides each group with a time slot of processor time. The 

tasks within the group are cooperatively scheduled to exploit 
the time slot assigned to the group. Dependencies between 

modules and tasks are maintained to assure that no 
difficulties arise amongst preemptively scheduled groups. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
MICROSOFT CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
MICROSOFT CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
D SOUZA DAVID
</INVENTOR-NAME>
<INVENTOR-NAME>
D'SOUZA, DAVID
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates generally to data
processing systems and, more particularly, to scheduling
of tasks in data processing systems.The Microsoft Windows, version 3.1, operating
system sold by Microsoft Corporation of Redmond,
Washington, is a message-driven operating system. Each
program run on the operating system maintains a message
queue for holding incoming messages that are destined for
some portion of the program. Messages are often destined
to windows generated by the program. Each window
generated by a program has an associated procedure. Thus,
the messages are not sent to the window per se, but rather
are sent to the associated procedureMessages are retrieved and processed from the
message queue by the associated program through execution
of a block of code known as the "message loop". Figure 1
is a flow chart of the steps performed by the message
loop. These steps are continuously repeated in a looping
fashion while the program is active. Initially, a message
is retrieved from the queue by making a call to the
GetMessage function (step 10). The GetMessage function is
responsible for retrieving a message (if one exists) from
the queue. Once the message is retrieved from the queue,
the message is translated (if necessary) into a usable
format by calling the TranslateMessage function, which
performs some keyboard translation (step 12). Once the
message is translated, the message is dispatched to the
appropriate procedure by calling the DispatchMessage
function (step 14). The message includes information that 
identifies a destination window. The information is used
to properly dispatch the message.The GetMessage function, described above, also
plays a role in the scheduling of tasks in the Microsoft
WINDOWS, Version 3.1, operating system. The operating
system adopts a non-preemptive or cooperative multi-tasking
approach. A task is a section of code, such as a
subroutine or program, that can run independently.
Cooperative multi-tasking refers to when tasks cooperate
with each other by voluntarily passing control over a
processor ("yielding") among each other. With preemptive
multi-tasking, in contrast, a scheduler determines which
task is given the processor and typically provides each
task with a given time slot in which it may run. The
GetMessage function is an example of a vehicle for
implementing the cooperative multi-tasking in the
operating system. Other operating system-provided
functions that help implement cooperative multi-tasking
include the PeekMessage, Yield and WaitMessage
</DESCRIPTION>
<CLAIMS>
Method for operating a data processing system (26) having at least one
processor (27) for running tasks, the method comprising the steps of:


logically partitioning (44) tasks into groups of inter-dependent tasks;
preemptively scheduling (46) the groups of tasks to be run such that each
group of tasks is given a time slot in a cycle in which its tasks may run on

the processor; and
for each group, non-preemptively scheduling (48) tasks to be run within
each group during the time slot allocated to the group.
The method according to claim 1, wherein the data processing system (26)
includes at least one storage device (30) and the method further comprises

the step of storing a group list (50) for each associated group in the storage
device, wherein each group list includes identifying information (52A-52D)

for tasks included in the associated group.
The method according to claim 1, further comprising the step of storing a
group list (50) for each group that holds identifying information for tasks

included in the group.
The method according to one of claims 1 to 3, further comprising the step of
storing status information (72A-72D) for each group (70A-70D) indicating

whether the group has a task that is running, and holding identifying
information (74A-74D) about any task that is running. 
The method according to one of claims 1 to 4, wherein the step of logically
partitioning (44) tasks into groups of inter-dependent tasks comprises the

steps of:

initially placing (54) each task in its own group; and
subsequently combining (58) groups of tasks into a merged group wherein
each task in the merged group calls a common module when run.
The method according to one of claims 1 to 5, wherein the step of logically
partitioning (44) tasks into groups of inter-dependent tasks comprises the

steps of:

providing a task dependency list for each task, said task dependency list
listing modules of code that are candidates to be called when the task is run

on the processor; and
examining the task dependency lists to logically partition the tasks into
groups of inter-dependent tasks.
The method according to one of claims 1 to 6, wherein the step of logically
partitioning (44) tasks into groups of inter-dependent tasks comprises the

steps of:

providing a module dependency list (76) for each associated module of
code, wherein each module dependency list lists interdependent modules of

code (78A-78C) of the associated module of code;
generating a task dependency list for each task by taking a logical union of
modules listed in the module dependency lists of modules that are

candidates to be called when the task is run on the processor; and
examining the task dependency lists to logically partition the tasks into
groups of inter-dependent tasks.
A data processing system (26), comprising:

partitioning means (27) for partitioning tasks into groups of inter-dependent
tasks;
execution means (27) for executing tasks;
a preemptive scheduler (42) for preemptively scheduling the groups of tasks
such that each group is given a time slot in which to execute one of its

tasks; and
a non-preemptive scheduler (42) for non-preemptively scheduling tasks
within each group.
The system according to claim 8, further comprising storage means (30) for
storing a group list (50) for each group, wherein each group list includes

identifying information (52A-52D) for tasks included in the group.
The system according to claim 8 or 9, further comprising means for storing
status information (72A-72D) for each group (70A-70D) indicating whether

the group has a task that is running, and for holding identifying information
(74A-74D) about any task that is running.
</CLAIMS>
</TEXT>
</DOC>
