<DOC>
<DOCNO>EP-0629302</DOCNO> 
<TEXT>
<INVENTION-TITLE>
PROCESS FOR LINKING PARTS OF A PROGRAMME INTO ONE PROGRAMME
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1212	G06F1212	G06F945	G06F945	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F12	G06F12	G06F9	G06F9	</CLASSIFICATIONS-FOURTH>
<APPLICANTS>
<APPLICANT-NAME>
SIEMENS AG
</APPLICANT-NAME>
<APPLICANT-NAME>
SIEMENS AKTIENGESELLSCHAFT
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
GOESMANN KLAUS
</INVENTOR-NAME>
<INVENTOR-NAME>
HAFER CHRISTIAN
</INVENTOR-NAME>
<INVENTOR-NAME>
LINDMEIER HORST
</INVENTOR-NAME>
<INVENTOR-NAME>
PLANKL JOSEF
</INVENTOR-NAME>
<INVENTOR-NAME>
WESTERHOLZ KARL
</INVENTOR-NAME>
<INVENTOR-NAME>
GOESMANN, KLAUS
</INVENTOR-NAME>
<INVENTOR-NAME>
HAFER, CHRISTIAN
</INVENTOR-NAME>
<INVENTOR-NAME>
LINDMEIER, HORST
</INVENTOR-NAME>
<INVENTOR-NAME>
PLANKL, JOSEF
</INVENTOR-NAME>
<INVENTOR-NAME>
WESTERHOLZ, KARL
</INVENTOR-NAME>
</INVENTORS>
<CLAIMS>
Method for linking program parts (PT1...PTn) to 
form a program which can be executed with minimum running 

time by a computer operating according to the cache 
principle, 


a) wherein a plurality of sequences (RF1...RFk) of 
program parts is generated pseud
o-randomly and the 
plurality of sequences is evaluated with respect to the 

running time and a first sequence of program parts, in 
which the number of cache misses is small, is selected, 
b) wherein processing continues with the first sequence 
of program parts (RFk), and in each case two program 

parts are permuted pseudo-randomly and it is then established 
whether the altered sequence leads to a better 

evaluation result, and in this case processing continues 
with the altered sequence as the current sequence, 

otherwise with the unaltered sequence of program parts. 
Method according to Claim 1,
 
wherein the step (b) is performed until a predetermined 

termination criterion is satisfied. 
Method according to Claim 2, wherein despite a 
negative result of the evaluation, processing continues 

with the altered sequence of program parts if the disadvantage 
of the evaluation result is less than a random  

 
number generated by a pseudo-random number generator 

scaled to the evaluation result of the current sequence. 
Method according to one of Claims 2 or 3, wherein 
the evaluation procedure is terminated whenever a predetermined 

number of evaluations has been performed. 
Method according to one of the preceding claims, 
wherein the evaluation is performed with the aid of a 

cache simulator. 
Method according to one of Claims 1 to 4, wherein 
the evaluation is performed with the aid of a cost 

function in the following manner: 

a) a trace procedure for the program comprising the 
program part that contains address calls to code areas or 

data areas of the program parts as trace result is 
performed, 
b) it is established from the trace result how often two 
program parts can displace each other at most, 
c) it is established for a pair of program parts in each 
case how large the overlapping of said program part pair 

is, expressed in cache blocks and given mapping of the 
program onto the cache, 
d) for each pair of program parts, the product of the 
number of displacements and the number of colliding, 

mutually overlapping cache blocks is formed, 
e) the sum of all products is formed to calculate the 
number of displacement misses of the program and hence as 

evaluation result. 
Method according to Claim 6, wherein, for calculating 
the number of displacements of the program part 

pairs, it is established on the basis of the call 
sequence of the program parts which program parts lie 

between two successive calls of a program part and it is 
calculated from this how often the program parts of a 

pair are successively called up. 
Method according to Claim 7, wherein an LRU stack 
memory is used to calculate the number of displacements, 

in that the elements indicating the calling program parts 
are inserted, and wherein, when a first program part is  

 
called up, by comparing said first program part with a 

program part already contained in the LRU stack memory it 
is established from the trace result, beginning at the 

top, whether said first program part has already been 
called up before, and if this is the case the program 

parts lying above the first program part contained in the 
LRU stack memory are noted and subsequently the first 

program part is shifted to the first position of the LRU 
stack memory. 
</CLAIMS>
</TEXT>
</DOC>
