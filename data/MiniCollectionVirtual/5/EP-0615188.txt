<DOC>
<DOCNO>EP-0615188</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Method for checking the correct execution of a multitasking computer program
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1128	G06F1128	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F11	G06F11	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A method for checking the correct execution of a multitasking computer program in which the tasks communicate by messages (i1,...in, o1, ok, om). Each task (T) issuing a message (ok) formulates an execution key (Cex(ok)) associated with this message and identifying a causal dependency relation for this message, defined by the chronological order of execution of the tasks and the chronological order for dealing with the messages by these tasks which led to the issuing of this message by this issuing task (T). Each execution key (Cex) is formulated by bit-by-bit addition ((+)) of binary words each containing the binary representation of an identifier of task (T), of message (ij) or of message time stamp ( theta (ij)). Before binary addition, the binary words have been cyclically permuted with different sizes (s(2j-1),s(2j),s(2n+1),s(2n+2)) for each of them. A program execution error is detected by comparing the execution key formulated last with a reference execution key. 
<
IMAGE
>
</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
GEC ALSTHOM TRANSPORT SA
</APPLICANT-NAME>
<APPLICANT-NAME>
GEC ALSTHOM TRANSPORT SA
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
BRES GUILLAUME
</INVENTOR-NAME>
<INVENTOR-NAME>
SIMON FRANCOIS
</INVENTOR-NAME>
<INVENTOR-NAME>
BRES, GUILLAUME
</INVENTOR-NAME>
<INVENTOR-NAME>
SIMON, FRANCOIS
</INVENTOR-NAME>
</INVENTORS>
<CLAIMS>
A method of checking correct execution of a multitasking computer 
program (10) by one or more processors (1, 1' 1") in which the tasks 

(Pa, Pb, Pc, Pd, Pe, Pf, T1, T2, T3, T) of the program emit messages 
(r2, r3, r4, r5, r6, r8, r9, 
a
, 
b
, 
c
, 
d
, o
k
) and are executed in 
response to such messages being taken into account, each message 

including a time stamp ((a), (b), (ij)), each message-emitting 
task creating an execution key (Cex(o
k
)) associated with said message 
and identifying a causal dependency relationship for said message 

defined by the chronological order of task execution and the 
chronological order in which the messages are taken into account by 

tasks that have caused the emitting task to emit messages, said 
method being characterized in that each execution key (Cex(o
k
)) is 
created by the bitwise combination (⊕) of binary words each 

containing the binary representation of a task identifier, a message 
identifier, or a message time stamp, with the bits of each binary 

word being firstly circularly permutated (P()) by different amounts 
(s(2j-1), s(2j), s(2n+1), s(2n+2)) for each word, and in that at 

least one of said tasks (Pa, Pe, T1, T2) emits one or more such 
messages in response to taking at least one input message (r1, r7, 
e
) 
into account, and in response to comparing the last execution key 

created by a task of the program with a reference key created from 
said input message(s), on the basis of which it is possible to detect 

an execution error. 
A method according to claim 1, in which each task (T) receiving a 
first message (i
j
) and task (T) emitting a second message (o
k
) 
creates an execution key (Cex(o
k
) for said second message by bitwise 
combination, after circular permutation by different amounts, of a 

binary word containing the binary representation of the identifier of 
the first message (i
j
), a binary word containing the binary 
representation of the time stamp ((i
j
)) associated with the first 
message, a binary word containing the binary representation of the 

identifier of said task (T), and a binary word containing the binary 
representation of the identifier of the second message (o
k
).  
 
A method according to claim 2, in which certain tasks receive an 
execution key (Cex(i
j
)) in parallel with a first message (i
j
) and 
emit a second message (o
k
), each of said certain tasks (T) creating 
an execution key (Cex(o
k
)) for said second message by bitwise 
combination, after circular permutation by the first different 

amounts (s(2j-1), s(2j), s(2n+1), s(2n+s)), of a binary word 
containing the binary representation of the identifier of the first 

message (i
j
), a binary word containing the binary representation of 
the
 time stamp ((i
j
)) associated with the first message, a binary 
word containing the binary representation of the identifier of said 

task (T), and a binary word containing the binary representation of 
the identifier of the second message (o
k
) in order to obtain a 
resulting binary word, and by bitwise combination, after circular 

permutation by second different amounts (N1, ... Nn), of the 
resulting binary word and the execution key received in parallel with 

the first message. 
A method according to claim 3, in which the first circular 
permutation amounts are given by a series of integer values held by 

each task. 
A method according to claim 3 or 4, in which the second circular 
permutation amounts are given by a counter forming part of the 

execution key received in parallel with the first message. 
A method according to any one of claims 1 to 5, in which said 
bitwise combination is a bitwise exclusive-OR. 
</CLAIMS>
</TEXT>
</DOC>
