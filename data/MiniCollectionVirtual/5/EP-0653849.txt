<DOC>
<DOCNO>EP-0653849</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Efficient utilization of present state/next state registers.
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1110	G06F1110	H03M1300	H03M1323	H03M1341	H03M1345	H04L2508	H04L2508	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	H03M	H03M	H03M	H03M	H04L	H04L	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F11	G06F11	H03M13	H03M13	H03M13	H03M13	H04L25	H04L25	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A technique is disclosed for efficiently utilizing memory in determining which next 
state accumulated cost to retain, such as in a communication system or a Viterbi 

decoder. The system includes a memory (110) having a portion of registers 
allocated to a first array (100) and a portion of registers allocated to a second array 

(120). 
The technique includes retrieving a present state accumulated cost from a 

storage register of the first array (100) and calculating a next state accumulated cost 
based on the present state accumulated cost. The next state accumulated cost is 

stored in a storage register of the second array (120). The second array (120) is 
designated as containing present state accumulated costs. A present state 

accumulated cost is retrieved from a storage register of the second array (120) and 
used in calculating a subsequent next state accumulated cost. The subsequent next 

state accumulated cost is stored in a storage register of the first array (100). 

</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
AT 
&
 T CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
AT
&
T CORP.
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
BLAKER DAVID MARK
</INVENTOR-NAME>
<INVENTOR-NAME>
DIAMONDSTEIN MARC STEPHEN
</INVENTOR-NAME>
<INVENTOR-NAME>
ELLARD GREGORY STEPHEN
</INVENTOR-NAME>
<INVENTOR-NAME>
MOBIN MOHAMMAD SHAFIUL
</INVENTOR-NAME>
<INVENTOR-NAME>
SAM HOMAYOON
</INVENTOR-NAME>
<INVENTOR-NAME>
THIERBACH MARK ERNEST
</INVENTOR-NAME>
<INVENTOR-NAME>
BLAKER, DAVID MARK
</INVENTOR-NAME>
<INVENTOR-NAME>
DIAMONDSTEIN, MARC STEPHEN
</INVENTOR-NAME>
<INVENTOR-NAME>
ELLARD, GREGORY STEPHEN
</INVENTOR-NAME>
<INVENTOR-NAME>
MOBIN, MOHAMMAD SHAFIUL
</INVENTOR-NAME>
<INVENTOR-NAME>
SAM, HOMAYOON
</INVENTOR-NAME>
<INVENTOR-NAME>
THIERBACH, MARK ERNEST
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
This invention relates generally to decoders. A Viterbi decoder is a maximum likelihood decoder that provides 
forward error correction. Viterbi decoders are used to decode a sequence of encoded 
symbols, such as a bit stream. The bit stream can represent encoded information in a 
telecommunication system. Such encoded information can be transmitted through 
various media with each bit (or set of bits) representing a symbol instant. In the 
decoding process, the Viterbi decoder works back through a sequence of possible bit 
sequences at each symbol instant to determine which one bit sequence is most likely 
to have been transmitted. The possible transitions from a bit at one symbol instant, 
or state, to a bit at a next, subsequent, symbol instant or state is limited. Each 
possible transition from one state to a next state can be shown graphically and is 
defined as a branch. A sequence of interconnected branches is defined as a path. 
Each state can transition only to a limited number of next states upon receipt of the 
next bit (or set of bits) in the bit stream. Thus, some paths survive and other paths 
do not survive during the decoding process. By eliminating those transitions that are 
not permissible, computational efficiency can be achieved in determining the most 
likely paths to survive. The Viterbi decoder typically defines and calculates a branch 
metric associated with each branch and employs this branch metric to determine 
which paths survive and which paths do not survive. A branch metric is calculated at each symbol instant for each possible 
branch. Each path has an associated metric, accumulated cost, that is updated at each 
symbol instant. For each possible transition, the accumulated cost for the next state 
is calculated as the lesser of the sum of the branch metric for the possible transitions 
and the path accumulated cost at the respective previous state. Prior art decoders have used two arrays of registers in a predefined 
group of memory locations within random access memory to store the present state 
accumulated costs and next state accumulated costs. The registers of a first array 
were used to store the present state accumulated costs. As the accumulated costs 
were calculated for the next symbol instant, the present state accumulated costs were 
read from registers of the first array and used in the calculations. The calculated 
accumulated costs for the next symbol instant, or next state, were written to registers  
 
of a second array. After all of the accumulated
</DESCRIPTION>
<CLAIMS>
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain in a communication system having a portion of 

memory allocated to a first array and a portion of memory allocated to a second 
array, the method including the steps of retrieving a present state accumulated cost 

from a storage register of a first array (100), calculating a next state accumulated cost 
based on the present state accumulated cost and storing the next state accumulated 

cost in a storage register of a second array (120) and, CHARACTERIZED 
BY 

   designating the second array (120) as containing a present state 
accumulated cost. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 1, further CHARACTERIZED 

BY 
   retrieving a present state accumulated cost from a storage register of the 

second array (120); 
   calculating a subsequent next state accumulated cost; and 

   storing the subsequent next state accumulated cost in a storage register 
of the first array (100). 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 2, further CHARACTERIZED 

BY 
   designating the first array (100) as again containing a present state 

accumulated cost; 
   retrieving a present state accumulated cost from a storage register of the 

first array (100); 
   calculating a next state accumulated cost at a subsequent symbol instant; 

   storing the next state accumulated cost at the subsequent symbol instant 
in a storage register of the second array (120). 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 1, further CHARACTERIZED 

BY
 

   retrieving a present state accumulated cost from a storage register of the 
second array (120); and 

   assessing whether the present state accumulated cost is accurate. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 4, further CHARACTERIZED 

BY 
   designating the first array (100) as again containing a present state 

accumulated cost; 
   retrieving a present state accumulated cost from a storage register of the 

first array (100); 
   calculating a next state accumulated cost; and 

   storing the next state accumulated cost in a storage register of the 
second array (120), whereby the next state accumulated costs are recalculated. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 5, wherein the step of designating 

the first array (100) as again containing a present state accumulated cost, is 
CHARACTERIZED BY changing the state of a flip-flop (144). 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 1, wherein the step of designating 

the second array (120) as containing a present state accumulated cost is 
CHARACTERIZED BY changing the state of a flip-flop (144). 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 1, wherein storing the next state 

accumulated cost in a storage register of a second array (120) is CHARACTERIZED 
BY storing the next state accumulated cost in a memory location in the second array 

(120) corresponding to the memory location in the first array (100) from which the 
present state accumulated cost was retrieved. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 1, wherein retrieving a present 

state accumulated cost from a first array (100) is CHARACTERIZED BY
 

   retrieving an accumulated cost associated with a first present state from 
a storage register of the first array (100), and 

   retrieving an accumulated cost associated with a second present state 
from a storage register the first array (100); and 

   wherein calculating a next state accumulated cost comprises 
   adding the accumulated cost associated with the first present state to a 

first branch metric resulting in a first potential accumulated cost; 
   adding the accumulated cost associated with the second present state to 

a second branch metric resulting in a second potential accumulated cost; and 
   selecting the smaller of the first and second potential accumulated costs 

as the next state accumulated cost. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 9, wherein selecting the smaller 

of the first and second potential accumulated costs as the next state accumulated 
cost, is CHARACTERIZED BY 

   subtracting one of the first and second potential accumulated costs from 
the other resulting in a difference; 

   identifying the most significant bit of a binary representation of the 
difference; and 

   determining the smaller of the first and second potential accumulated 
costs as the next state accumulated cost by the most significant bit of the binary 

representation of the difference (184). 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 9, wherein, selecting the smaller 

of the first and second potential accumulated costs as the next state accumulated 
cost, is CHARACTERIZED BY 

   comparing the first and second potential accumulated costs to determine 
which is smaller. 
A method of efficiently utilizing memory in determining which next 
state accumulated cost to retain as recited in claim 11, wherein comparing the first 

and second potential accumulated costs to determine which is smaller is 
CHARACTERIZED BY

 
   subtracting one of the first (168) and second (172) potential accumulated 

costs from the other resulting in a difference (182); 
   identifying the most significant bit of a binary representation of the 

difference (184); and 
   determining the smaller of the first (168) and second (172) potential 

accumulated costs as the next state accumulated cost by the most significant bit of 
the binary representation of the difference (184). 
A method of efficiently utilizing resources in determining which next 
state accumulated cost to retain in a Viterbi decoder having a portion of memory 

allocated to a first array and a portion of memory allocated to a second array, the 
method including the steps of 

   retrieving a present state accumulated cost from a storage register of a 
first array (100), 

   calculating a next state accumulated cost based on the present state 
accumulated cost, 

   storing the next state accumulated cost in a storage register of a second 
array (120), an
d 
   repeating steps there until the next state accumulated cost has been 

stored in respective storage registers of the second array (120) for each of the states 
at a first symbol instant, CHARACTERIZED BY 


a) designating the second array (120) as containing a present state 
accumulated cost; 
b) retrieving a present state accumulated cost from a storage register of 
the second array (120); 
c) calculating a subsequent next state accumulated cost based on the 
present state accumulated cost retrieved from the second array (120); 
d) storing the subsequent next state accumulated cost in a storage 
register of the first array (100); and 
e) repeating steps f, g, and h until the subsequent next state accumulated 
cost has been stored in a storage register of the first array (100) for each of the states. 
In a Viterbi decoder for determining the lower next state accumulated 
cost for each possible transition at a series of symbol instants, said decoder including 

memory having a portion allocated to a first array and a portion allocated to a second 
array, a method for determining which next state cost to retain, comprising the steps 

 
of: 

   retrieving an accumulated cost associated with a first present state from 
a storage register of a first array (100); 

   adding the accumulated cost associated with the first present state to a 
first branch metric (152) resulting in a first potential accumulated cost (162 or 168); 

   retrieving an accumulated cost associated with a second present state 
from a storage register of the first array (100); 

   adding the accumulated cost associated with the second present state to 
a second branch metric (152) resulting in a second potential accumulated cost (164 

or 172); 
   selecting the smaller of the first and second potential accumulated costs 

as the next state accumulated cost (146); 
   storing the next state accumulated cost (146) in a storage register of a 

second array (120), CHARACTERIZED BY 
   designating the second array (120) as containing a present state 

accumulated cost; 
   calculating a subsequent next state accumulated cost; and 

   storing the subsequent next state accumulated cost in a storage register 
of the first array (100). 
A method for determining the lower next state accumulated cost as 
recited in claim 14, wherein selecting the smaller of the first and second potential 

accumulated costs as the next state accumulated cost, is CHARACTERIZED BY 
   subtracting one of the first (162 or 168) and second (164 or 172) 

potential accumulated costs from the other resulting in a difference (182); 
   identifying the most significant bit of a binary representation of the 

difference (184); and 
   determining the smaller of the first (168) and second (172) potential 

accumulated costs as the next state accumulated cost by the most significant bit of 
the binary representation of the difference (184). 
A method for determining the lower next state accumulated cost as 
recited in claim 14, further CHARACTERIZED BY 

   calculating a branch metric corresponding to a transition from the 
present state to a next state. 
An integrated circuit for processing signals, including storage means 
(110) defining a first array of registers (100) and a second array of registers (120), 

means for retrieving (144, 102, 190), a present state accumulated cost from a register 
of the first array (100), means for calculating (154, 150, 180, 184) a next state 

accumulated cost, means for storing (190, 26, 144, 102, 190) the next state 
accumulated cost in a register of the second array (120), CHARACTERIZED BY 

   means for designating (144) the first array (100) of registers as the 
former second array (120) of registers and the second array of registers as the former 

first array of registers, such that subsequent retrieving of an accumulated cost from a 
register of the first array (100) retrieves a next state accumulated cost. 
</CLAIMS>
</TEXT>
</DOC>
