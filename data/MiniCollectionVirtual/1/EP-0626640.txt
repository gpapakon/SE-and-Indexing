<DOC>
<DOCNO>EP-0626640</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Program translator with selective data value amendment and processor with data extension instructions
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F945	G06F945	G06F9305	G06F9305	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F9	G06F9	G06F9	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A program translator has the following units: 
An option direction unit for directing a code generation 
unit to generate or not to generate an amendment instruction 

to compensate an overflow in an arithmetic operation. 
A code generation unit for generating an amendment 
instruction to compensate an overflow by discriminating the 

type of a data variable to be an operand for an arithmetic 
operation of a machine instruction when effective width of the 

data variable designated by an operand is smaller than the 
width of a register to store the data variable and when an 

overflow may be caused. 
</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
MATSUSHITA ELECTRIC IND CO LTD
</APPLICANT-NAME>
<APPLICANT-NAME>
MATSUSHITA ELECTRIC INDUSTRIAL CO., LTD.
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
KAMIYAMA HIROSHI
</INVENTOR-NAME>
<INVENTOR-NAME>
MIYAJI SHINYA
</INVENTOR-NAME>
<INVENTOR-NAME>
SUZUKI MASATO
</INVENTOR-NAME>
<INVENTOR-NAME>
KAMIYAMA, HIROSHI
</INVENTOR-NAME>
<INVENTOR-NAME>
MIYAJI, SHINYA
</INVENTOR-NAME>
<INVENTOR-NAME>
SUZUKI, MASATO
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to a program translator for
translating high-level language programs into machine language,
and to a processor for processing machine language programs.Along with the development of electronics technology, data
processors such as micro computers have been widely used.The conventional processors can be classified into CISC
(Complex Instruction Set Computers) processors supporting a
large number of instructions or RISC (Reduced Instruction Set
Computers) processors supporting far fewer instructions to
achieve high-speed processing. The CISC processors include
TRON-spec. chips and MC68040 whereas the RISC processors
include SPARC and MIPS. Most of the conventional processors
have 32-bit registers and a 32-bit calculator.In a 32-bit CISC processor, the arithmetic instructions
can manipulate 8, 16, cr 32 bits of data, so that a compiler
for the CISC processor (hereinafter CISC compiler) generates
various instructions (codes) in accordance with the various
data width. For example, when an 8-bit character type data
variable or 16-bit short integer type data variable is stored
to the 32-bit registers, instructions are generated so that the 
variable is stored to the lower 8 bits or the lower 16 bits respectively without updating the
higher 24 bits or the higher 16 bits respectively.The large number of instructions requires the ClSC processor to have large and
complicated hardware to decode and to execute these instructions.This disadvantage of the CISC processors has been resolved by the RISC
processors. The types of instructions supported by the RISC processors are much fewer
and there is no instruction that updates only the lower 8 bits or the lower 16 bits.Accordingly, an instruction (code) to be generated by a compiler for a RISC
processor (hereinafter RISC compiler) to store an 8-bit character type data variable or 16-bit
short integer type data variable to the 32-bit register updates all the bits in the register.After the instruction is generated, the RISC compiler has to generate another
instruction to amend the higher 24 bit data or the higher 16 bit data so that the updated data
variable can be an 8-bit character type data variable or a 16-bit short integer type data
variable. This is to compensate for overflow which might be caused by arithmetic
operations for data variables. To be more specific, the possible data variable ranges are as
follows (numbers are all decimal).
128 to +127 for signed character type data variables
   0 to +255 for unsigned character type data
</DESCRIPTION>
<CLAIMS>
An apparatus for generating machine language instructions including arithmetic
instructions, based on a high level language program, said apparatus comprising:

   indication means (6) for holding an indication whether overflows caused by said
arithmetic instructions should be compensated or not;

   
characterised in that
 the apparatus further comprises:

instruction generation means (5) for, if said indication means (6)
currently holds an indication for compensating overflows, judging a type of a data

variable (at step 32, at step 132), which is specified by an operand of an arithmetic
instruction in the machine language program, and generating (at steps 34 to 38, at steps

134 to 138), according to the type of the data variable, an amendment instruction for
compensating an overflow which may be caused by the arithmetic instruction, said

amendment instruction having a least word length and extending an effective width of
the data variable to a width of a register (13) which stores the variable;
wherein said amendment instruction generated by the instruction generation
means (5) is added to the machine language program immediately after the arithmetic

instruction.
The apparatus of claim 1, wherein said instruction generation means (5)
comprises:


instruction selection means (at step 27, at step 127) for selecting arithmetic
instructions where an overflow may occur from all of said machine language

instructions that can be generated;
variable detection means for detecting the effective width of a data variable (at
step 32, at step 132) in said arithmetic instruction and for judging whether said data

variable is signed or unsigned (at step 33, at step 36, at step 133, at step 136);
sign extension instruction generation means for, when said data variable is
signed, generating an amendment instruction for filling higher bits than said effective

width with the same logical values as a sign bit (at step 34, at step 37, at step 134, at 
step 137), thereby matching said effective width of said data variable with said width of

said register (13); and zero extension instruction generation means for, when said data
variable is unsigned, 
generating an amendment instruction to fill higher bits than said
effective width with zeros (at step 35, at step 38, at step 135, at step 138), thereby

matching said effective width of said data variable with said width of said register (13).
The apparatus of claim 2, wherein said data variable is 32 bits wide and the
number of bits in said register (13) is an integer between 33 and 63 inclusive.
The apparatus of claim 2, wherein said data variable is 16 bits wide and the
number of bits in said register (13) is an integer between 17 and 31 inclusive.
The apparatus of claim 2, wherein said data variable is one of 16 bits wide and
8 bits wide, and the number of bits in the said register (13) is 24.
A processor (7) for executing machine language instructions generated by a
program translation apparatus, said processor (7) comprising:


means for decoding (12) said machine language instructions including
amendment instructions for compensating overflows and arithmetic instructions;
a plurality of registers (13) having a first data width for storing data having a
second data width, said data being necessary for arithmetic operations;
a calculator (14) for performing a predetermined arithmetic operation with said
data stored in said register (13), based on said arithmetic instruction decoded by said

decoding means (12); and
amendment means (15, 16) for extending the effective width of said data to said
first data width, based on said amendment instructions decoded by said decoding means

(12), said amendment instructions having a least word length.
The processor of claim 6, wherein said amendment means (15, 16) comprises:

a first extender (15) for, when a said amendment instruction decoded indicates
sign extension, filling higher bits than said effective width with same logical values as a sign

bit, thereby matching said effective width of a data variable with said first data width;
and
a second extender (16) for, when a said amendment instruction decoded
indicates zero extension, filling higher bits than said effective width with zeros, thereby

matching said effective width of said data variable with said first data width.
</CLAIMS>
</TEXT>
</DOC>
