<DOC>
<DOCNO>EP-0646865</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Executing programs of a first system on a second system
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F2100	G06F1310	G06F100	G06F1310	G06F946	G06F100	G06F9455	G06F9455	G06F946	G06F2100	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F21	G06F13	G06F1	G06F13	G06F9	G06F1	G06F9	G06F9	G06F9	G06F21	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
An emulator executes on a second data processing system as a second system user 

level process including a first system user level program, a first system executive program, 
and first system user and executive tasks. An emulator level is interposed between the 

second system user level process and a kernel level and contains pseudo device drivers. 
Each pseudo device driver corresponds to a first system input/output device. The kernel 

level includes kernel processes, each kernel process corresponding to a pseudo device 
driver. The second system hardware platform includes a plurality of second system 

input/output devices, wherein each second system input output device corresponds to a 
kernel process. Each combination of a pseudo device driver, a corresponding kernel 

process and a corresponding second system input/output device executes in a second 
system process and emulates the operations of a corresponding first system input/output 

task and the corresponding first system input/output device. The pseudo device drivers 
are constructed of a plurality of pseudo device queues, a return queue and a queue 

manager. 

</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
BULL HN INFORMATION SYST
</APPLICANT-NAME>
<APPLICANT-NAME>
BULL HN INFORMATION SYSTEMS INC.
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
BIANCHI RICHARD S
</INVENTOR-NAME>
<INVENTOR-NAME>
FLYNN DENNIS R
</INVENTOR-NAME>
<INVENTOR-NAME>
FOGELGREN MARCIA T
</INVENTOR-NAME>
<INVENTOR-NAME>
LEMAY RICHARD A
</INVENTOR-NAME>
<INVENTOR-NAME>
TOVELL MARY E
</INVENTOR-NAME>
<INVENTOR-NAME>
WOODS WILLIAM E
</INVENTOR-NAME>
<INVENTOR-NAME>
BIANCHI, RICHARD S.
</INVENTOR-NAME>
<INVENTOR-NAME>
FLYNN, DENNIS R.
</INVENTOR-NAME>
<INVENTOR-NAME>
FOGELGREN, MARCIA T.
</INVENTOR-NAME>
<INVENTOR-NAME>
LEMAY, RICHARD A.
</INVENTOR-NAME>
<INVENTOR-NAME>
TOVELL, MARY E.
</INVENTOR-NAME>
<INVENTOR-NAME>
WOODS, WILLIAM E.
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to a method and apparatus for executing programs of
a first system on a second system and, more particularly, to a method and apparatus for
emulating a first operating system and hardware platform on a second operating system
and hardware platform.A recurring problem in computer systems is that of executing, or running,
programs written for a first computer system having a first hardware platform, that is,
processor, memory and input/output devices, on a second computer system having a
second and different hardware platform. The problem is compounded when the second
computer system, as is frequently the case, uses a second operating system which may be
substantially different from the operating system of the first system.This problem usually occurs when a user or a manufacturer of computer systems is
attempting to move application programs from a first system to a second system to
upgrade or update the computer system while, at the same time, preserving the user's
investment in application programs and data created through the application programs.
This situation may arise, for example, when moving application programs from one
proprietary system, that is, a system having an operating system and hardware platform
which is particular to one manufacturer, to another proprietary system OR when moving
application programs from a proprietary system to a "commodity" system, that is, a system
having a hardware platform and operating system which is used by many manufacturers.The problems arising from moving application programs from a first system to a
second system arise from the fundamental functional structure of the systems and from the
interactions and interrelationships of the functional elements of the systems. Computer systems are constructed as layered levels of functionality wherein the
three principal layers in any system are, from top to bottom, the user programs, the
operating system and the hardware "platform". The user programs provide the primary
interface to the users and provide the functions and operations to control the system in
performing the specific operations desired by the user to perform the user's work, such as
word processing. spread sheets, and so forth. The hardware is comprised of the central
processing unit, the memory and the input/output devices, such as displays, printers, disk
drives and communications devices, which actually perform the required operations at the
detailed level.The operating system is functionally located "between" the user
</DESCRIPTION>
<CLAIMS>
An emulator for emulating a first data processing (DP)
system (10) on a second data processing (DP) system (54);

the first DP system (10) including:

a user level (12);
an executive level (16);
an input/output (I/O) level (18); and
a hardware platform (20); wherein
the user level (12) includes at least one user program
(22) and at least one executive program (24) for managing

operations of the first DP system (10);
the executive level (16) includes at least one user
task (30) performing user level program operations and at

least one executive task (28) performing executive program
operations, the user and executive tasks (30, 28) generating

requests for first system I/O operations;
the I/O level (18) includes a plurality of I/O tasks
(46); each I/O task (46) corresponding to a first system

I/O device (26c), performing I/O operations in response to
the I/O requests, and controlling the corresponding first system

I/O devices (26c); and
the hardware platform (20) includes a plurality of first
system I/O devices (26c) and a first system memory (26b);

said emulator which is executing on the second DP system (54)
is characterized by:
a second system user level process (80) executing in
a user level (62) of the second DP system (54), said second

system user level process (80) including

(i) the first system user level program (22),
(ii) the first system executive program (24), and
(iii) the first system user and executive tasks (30, 28);
an emulator level (68) being interposed between the
second system user level process (80) and a kernel level (64),
a plurality of pseudo device drivers (74) included in
said emulator level (68),
a plurality of kernel processes (66), each one corresponding
to a pseudo device driver (74), being included in

said kernel level (64); and
a second system hardware platform (56) including a plurality
of second system I/O devices (58c), each one corresponding

to a kernel process (66); wherein
each combination of a pseudo device driver (74), a corresponding
kernel process (66) and a corresponding second system

I/O device (58c) execute in a second system emulation process
(82) and emulate the operations of a corresponding first system

I/O task (46) and corresponding I/O device (26c).
The emulator of claim 1, wherein the plurality of pseudo
device drivers (74) are further characterized by:


a plurality of pseudo device queues (86) each one corresponding
to a pseudo device driver (74);
a return queue (88); and
a pseudo device queue manager (84);
each pseudo device queue (86) including a device queue
frame (94/86) for each I/O request directed to the corresponding

first system I/O device (26c) wherein each kernel process
(66) is responsive to a request stored in a device queue frame

(94/86) for reading the I/O request from said frame and controlling
the corresponding second system I/O device (58c) in

executing the I/O request;
the return queue (88) including a return queue frame
(94/88) for each I/O request executed by a kernel process (66)

wherein each kernel process (66) is responsive to the completion
of the execution of an I/O request for writing a request

result into a return queue frame (94/88); and
the pseudo device queue manager (84) being responsive
to each I/O request generated by a task (46) for writing 

the I/O request into the pseudo device queue (86) corresponding
to the first system I/O device (26c) that the I/O request is

directed to, and responsive to each return queue frame (94/88)
for providing the request result to the task (46) which generated

the corresponding I/O request.
The emulator of claim 2 wherein each I/O request generated
by a task (46) is associated with an I/O instruction

and wherein the pseudo device queue manager is
further characterized by an instruction monitor (100) for

detecting first system I/O instructions and generating an
I/O instruction output indication upon the occurrence of an

I/O instruction wherein the said indication is provided for
writing the associated I/O request into the pseudo device

queue (86) corresponding to the first system I/O device (26c)
to which the I/O request is directed.
The emulator of claim 2 or 3 wherein the pseudo device
queue manager is further characterized by a queue

read mechanism (84) responsive to the writing of a return
queue frame (94/88) into the return queue (88) for reading

the request result from the return queue frame (94/88) and
providing the request result to the task (46) that generated

the corresponding I/O request.
The emulator of claim 4 wherein each pseudo device queue
(86) is further characterized by a queue header (90) which

includes a semaphore (102) settable by the queue manager
(84) when writing a queue frame (94/86) to the pseudo device

queue (86) by the queue manager (84), wherein

each kernel process (66) is responsive to the setting
of the semaphore (102) in the queue header (90) of the corresponding

queue frame (94/86) from the pseudo device queue (86)
and for setting the semaphore (102) when reading a queue frame

(94/86) from the pseudo device queue (86), and wherein
the queue manager (84) and the kernel process (66)
corresponding to a pseudo device queue (86) is responsive 

to the semaphore (102) of the queue header (90) to inhibit
writing a queue frame (94/86) into the pseudo device queue

(86) and reading a queue frame (94/86) from the pseudo device
queue (86) when a queue frame (94/86) is being written to

and read from the pseudo device queue (86).
A method for emulating a first data processing (DP)
system (10) on a second data processing (DP) system (54);

the first DP system (10) including:

a user level (12);
an executive level (16);
an input/output (I/O) level (18); and
a hardware platform (20); wherein
the user level (12) includes at least one user program
(22) and at least one executive program (24) for managing

operations of the first DP system (10);
the executive level (16) includes at least one user
task (30) performing user level program operations and at

least one executive task (28) performing executive program
operations, the user and executive tasks (30, 28) generating

requests for first system I/O operations;
the I/O level (18) includes a plurality of I/O tasks
(46); each I/O task (46) corresponding to a first system

I/O device (26c) and performing I/O operations in response to
the I/O requests and each first system I/O device (26c) performing

I/O operations in response to the corresponding I/O task
(46); and
the hardware platform (20) includes a plurality of first
system I/O devices (26c) and a first system memory (26b);
characterized by:
executing a second system user level process (80) in a
user level (62) of the second DP system (54) wherein an emulator

level (68) is interposed between a second system user
level process (80) and a kernel level (64) with a plurality

of pseudo device drivers (74) being included in said emulator
level (68), 
including into said second system user level
process (80):


(i) the first system user level program (22),
(ii) the first system executive program (24), and
(iii) the first system user and executive tasks
(30, 28);
establishing a correspondence between said pseudo device
drivers (74) and the first system I/O devices (26c);
executing a plurality of kernel processes (66) on the
kernel level (64), each kernel process (66) corresponding to

a pseudo device driver (74);
providing a plurality of second system I/O devices (58c)
each one corresponding to a kernel process (66);
executing each combination of a pseudo device driver
(74), a corresponding kernel process (66) and a corresponding

second system I/O device (58c) which is executing in a second
system emulation process (82); and
in each second system emulation process (82), emulating
the operations of a corresponding first system I/O task (46)

and a corresponding I/O device (26c).
The method of claim 6 wherein the step of constructing
a plurality of pseudo device drivers (74) is further characterized

by:

constructing a plurality of pseudo device queues (86)
each one corresponding to a pseudo device driver (74);
constructing a return queue (88); and
constructing a pseudo device queue manager (84);
each pseudo device queue (88) including a device queue
frame (94/86) for each I/O request directed to the corresponding

first system I/O device (26c) wherein each kernel process
(66) is responsive to a request stored in a device queue frame

(94/86) for reading the I/O request from said frame and controlling
the corresponding second system I/O device (58c) in

executing the I/O request;
the return queue (88) including a return queue frame
(94/88) for each I/O request executed by a kernel process (66) 

wherein each kernel process (66) is responsive to the completion
of the execution of an I/O request for writing a

request result into a return queue frame (94/88); and
the pseudo device queue manager (84) being responsive
(i) to each I/O request generated by a task (46) for

writing the I/O request into the pseudo device queue (86)
corresponding to the first system I/O device (26c) that the

I/O request is directed to, and (ii) to each return queue
frame (94/88) for providing the request result to the task

(46) which generated the corresponding I/O request.
The method of claim 7 wherein each I/O request generated
by a task (46) is associated with an I/O instruction, and

wherein writing I/O requests into the pseudo device queues
(86) is characterized by the further steps of:


detecting first system I/O instructions;
generating an I/O instruction output indication upon
the occurrence of an I/O instruction; and
responsive to an I/O instruction indication, writing
the associated I/O request into the pseudo device queue (86)

corresponding to the first system I/O device (28c) to which
the I/O request is directed.
The method of claim 7 wherein the step of reading a request
result from the return queue (88) is characterized by

the further steps as follows:

responsive to the writing of a return queue frame (94/88)
into the return queue (88), reading the request result from

the return queue frame (94/88), and
providing the request result to the task (46) that
generated the corresponding I/O request.
</CLAIMS>
</TEXT>
</DOC>
