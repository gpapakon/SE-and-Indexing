<DOC>
<DOCNO>EP-0632364</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Efficient storage of object in a file system
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F1200	G11B2012	G06F306	G06F306	G11B2732	G06F1200	G11B2012	G11B2732	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G11B	G06F	G06F	G11B	G06F	G11B	G11B	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F12	G11B20	G06F3	G06F3	G11B27	G06F12	G11B20	G11B27	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A file system provides a hierarchical approach to 
storage of file data. Logically contiguous bytes of file data 

are stored in stream data structures, and streams which hold 
related file data are stored in a variable sized onode data 

structures on disk. The variable-sized onode data structures 
are stored in fixed sized buckets, and the buckets are 

organized into a variable sized array. Thus, the file system 
provides a combination of variable-sized storage with 

fixed-sized storage to provide a very efficient approach to 
storing file data. In addition, indexes may be provided 

within the structures to allow quick access to onodes and 
streams. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
MICROSOFT CORP
</APPLICANT-NAME>
<APPLICANT-NAME>
MICROSOFT CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
BERKOWITZ BRIAN T
</INVENTOR-NAME>
<INVENTOR-NAME>
FERGUSON ROBERT I
</INVENTOR-NAME>
<INVENTOR-NAME>
ZBIKOWSKI MARK
</INVENTOR-NAME>
<INVENTOR-NAME>
BERKOWITZ, BRIAN T.
</INVENTOR-NAME>
<INVENTOR-NAME>
FERGUSON, ROBERT I.
</INVENTOR-NAME>
<INVENTOR-NAME>
ZBIKOWSKI, MARK
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates generally to data
processing systems and, more particularly, to efficient
storage of objects in a file system.In conventional operating systems, each file is
allocated a fixed number of blocks of disk space for
storing file data as well as control information about the
file. The blocks are fixed-sized so that the blocks may
be quickly allocated and deallocated. The control
information for the files and the file data are often
variable-sized, which poses at least two problems. First,
when the control information and/or file data is not large
enough to fill a block, disk space within the block is
wasted. Second, when the control information and/or file
data is too large to be stored in a single block, it must
be stored in multiple blocks and multiple pointers are
maintained to specify where the data is stored.
Maintaining and using such pointers is often quite
cumbersome. US patent no. 5,206,939 discloses an apparatus and a method for disk mapping and
data retrieval including a data storage medium on which has been stored a plurality
of data records. Each record includes at least a record identification portion, for
uniquely identifying each record from among the plurality of data records. The
apparatus builds a record locator table and high speed semiconductor memory
which comprises the unique record identifiers for the records on the storage medium
as well as a record locator index generated by the apparatus, which indicates the
address of the data record on the storage medium. Data retrieval is facilitated by
first searching the record locator table in high speed semiconductor memory for a
requested data record. Utilizing the record locator index associated with the
requested data record, the system directly accesses the requested data record on
the storage medium thereby minimizing storage medium search time.Thus, it is the object of the invention to provide a method and system for
storing objects more efficiently in a file system.This object is solved by the method as claimed in independent claim 1,
the system as claimed in independent claim 7, and the storage medium as claimed in
independent claim 21. Preferred embodiments of the invention are subject matters
of dependent claims.In accordance with a first aspect of the present
invention, a method and system are practiced for storing
file data in secondary storage having memory space. The
data processing system for practicing this method includes
the secondary storage as well as internal storage. At
least a portion of
</DESCRIPTION>
<CLAIMS>
A method, for use in a data processing system (10) having secondary storage
(16) with memory space, of storing file data in the secondary storage (16), the

method comprising:

logically partitioning at least a portion of the memory space in the
secondary storage (16) into fixed-sized data structures (Buckets 1 to N);

   
characterized by
storing a first set of logically contiguous file data in a first variable-sized
data structure (40);
storing a first identifier (36) in the first set of logically contiguous file data
to uniquely identify the first set of logically contiguous file data among

other sets of logically contiguous file data held in the first variable-sized
data structure (40);
storing a B-tree index (83) of multiple entries in the first variable-sized
data structure (40) in the secondary storage (16), said entries including

the identifier (36) that uniquely identifies the first set of logically
contiguous file data;
storing a second identifier (44) in the first variable-sized data structure
(40) that uniquely identifies the first variable-sized data structure (40)

within a fixed-sized data structure (Buckets 1 to N);
storing the first variable-sized data structure (40) in at least one of the
fixed-sized data structures (Buckets 1 to N) in the secondary storage (16);

and 
storing a map (74) of multiple entries in the secondary storage (16), said
entries including the identifier (44) that uniquely identifies the first

variable-sized data structure (40).
The method recited in claim 1, further comprising:

storing a second set of logically contiguous file data in a second variable-sized
data structure (40);
storing a first identifier (36) in the second set of logically contiguous file
data to uniquely identify the second set of logically contiguous file data

among other sets of logically contiguous file data held in the second
variable-sized data structure (40);
storing a B-tree index (83) of multiple entries in the second variable-sized
data structure (40) in the secondary storage (16), said entries including

the identifier (36) that uniquely identifies the second set of logically
contiguous file data;
storing a second identifier (44) in the second variable-sized data structure
(40) that uniquely identifies the second variable-sized data structure (40)

within a fixed-sized data structure (Buckets 1 to N);
storing the second variable-sized data structure (40) in the fixed-sized
data structure (Buckets 1 to N) wherein the first variable-sized data

structure (40) is stored; and
storing in the map (74) the identifier (44) that uniquely identifies the
second variable-sized data structure (40).
The method recited in claim 1 or 2 wherein the step of logically partitioning at
least a portion of the memory space in the secondary storage (16) into fixed-sized

data structures (Buckets 1 to N) further comprises:

logically partitioning at least a portion of memory in the secondary storage
(16) into a variable-sized array (72) of the fixed-sized data structures

(Buckets 1 to N).
The method recited in claim 1 or 2 wherein the secondary storage (16) is disk
storage, and wherein the step of logically partitioning at least a portion of the

memory space in the secondary storage (16) further comprises:

logically partitioning at least a portion of the memory space in the disk
storage (16) into fixed-sized data structures (Buckets 1 to N).
The method recited in one of claims 1 to 4, further comprising:

storing property information (42, 44, 46, 48, 50, 58, 60, 62, 64, 66, 68, 70)
about the first variable-sized data structure (40) in the secondary storage

(16).
The method recited in claim 5, further comprising:

querying the first variable-sized data structure (40) to obtain the property
information (42, 44, 46, 48, 50, 58, 60, 62, 64, 66, 68, 70) stored therein.
The method recited in one of claims 1 to 6 wherein the step of storing a B-tree
index (83) of multiple entries in the first variable-sized data structure (40) in the

secondary storage (16) further comprises:

storing the B-tree index (83) in the secondary storage (16) as a set of
logically contiguous file data (80, 81).
The method recited in one of claims 1 to 7, further comprising:

locating the first set of logically contiguous file data in the first variable-sized
data structure (40) in the secondary storage (16) by accessing the

B-tree index (83).
The method recited in one of claims 1 to 8, further comprising:

allocating additional memory space in the secondary storage (16) to fulfill
growing requirements of the first variable-sized data structure (40),

comprising:

determining whether the fixed-sized data structure (Buckets 1 to N)
that currently stores the first variable-sized data structure (40) has

sufficient free memory space to fulfill the growing requirements of the
first variable-sized data structure (40); 
when the fixed-sized data structure (Buckets 1 to N) that currently
stores the first variable-sized data structure (40) has sufficient free

memory space, allocating additional space into the fixed-sized data
structure to the first variable-sized data structure (40) to fulfill the

growing requirements of the first variable-sized data structure (40);
and
when the fixed-sized data structure (Buckets 1 to N) that currently
stores the first variable-sized data structure (40) does not have

sufficient free memory space, finding at least one other of the fixed-sized
data structures (Buckets 1 to N) that has sufficient memory

space to fulfill the growing requirements of the first variable-sized
data structure (40) and moving the first variable-sized data structure

(40) to the found at least one other of the fixed-sized data structures
(Buckets 1 to N).
The method of claim 9 wherein the step of finding at least one other of the
fixed-sized data structures (Buckets 1 to N) that has sufficient memory space to

fulfill the growing requirements of the first variable-sized data structure (40)
further comprises:


finding at least one other of the fixed-sized data structures (Buckets 1 to
N) that has sufficient memory space to fulfill the growing requirements of

the first variable-sized data structure (40) that is in closest proximity in the
secondary storage (16) to the fixed-sized data structure (40) that currently

holds the first variable-sized data structure (40).
The method recited in one of claims 1 to 10, further comprising:

locating the first variable-sized data structure (40) having a selected
identifier (44) by using the map (74) to locate the at least one of the fixed-sized

data structures (Buckets 1 to N) in which the first variable-sized data
structure (40) is stored and searching the at least one of the fix
ed-sized
data structures (Buckets 1 to N) to locate the first variable-sized data

structure (40) having the selected identifier (44).
The method recited in one of claims 1 to 11, further comprising:

storing a free list in the map (74), said free list including identifiers (44) of
cells of space in the secondary storage (16) that are unallocated;
determining if the free list contains a second identifier (44) for at least one
cell; and
where the free list contains a second identifier (44) for at least one cell,
assigning a selected identifier (44) of a cell from the free list to a new

variable-sized data structure (40) and storing the new variable-sized data
structure (40) in the cell.
The method recited in claim 12, further comprising:

where the free list contains no cells, adding additional entries to the map
(74), said additional entries including new identifiers (44) to new free

cells.
The method recited in claim 13, further comprising:

assigning one of the new identifiers (44) associated with one of the new
free cells to the new variable-sized data structure (40); and
storing the new variable-sized data structure (40) in the new free cell
associated with the new identifier (44) that is assigned to the new

variable-sized data structure (40).
The method recited in one of claims 12 to 14, further comprising:

using the map (74) to locate a second identifier (44) in the free list.
A data processing system (10), comprising:

internal memory (14);
secondary storage (16);
means (12, 24) for logically partitioning at least a portion of memory space
in the secondary storage (16) into fixed-sized data structures (Buckets 1

to N);
characterized by
means (12, 24) for storing a first set of logically contiguous file data in a
first variable-sized data structure (40);
means (12, 24) for storing a first identifier (36) in the first set of logically
contiguous file data to uniquely identify the first set of logically contiguous

file data among other sets of logically contiguous file data held in the first
variable-sized data structure (40);
means (12, 24) for storing a B-tree index (83) of multiple entries in the first
variable-sized data structure (40) in the secondary storage (16), said

entries including the identifier (36) that uniquely identifies the first set of
logically contiguous file data;
means (12, 24) for storing a second identifier (44) in the first variable-sized
data structure (40) that uniquely identifies the first variable-sized

data structure (40) within a fixed-sized data structure (Buckets 1 to N);
means (12, 24) for storing the first variable-sized data structure (40) in at
least one of the fixed-sized data structures (Buckets 1 to N) in the

secondary storage (16); and
means (12, 24) for storing a map (74) of multiple entries in the secondary
storage (16), said entries including the identifier (44) that uniquely

identifies the first variable-sized data structure (40).
The data processing system (10) as recited in claim 16, further comprising:

means (12, 24) for storing a second set of logically contiguous file data in
a second variable-sized data structure (40);
means (12, 24) for storing a first identifier (36) in the second set of
logically contiguous file data to uniquely identify the second set of

logically contiguous file data among other sets of logically contiguous file
data held in the second variable-sized data structure (40);
means (12, 24) for storing a B-tree index (83) of multiple entries in the
second variable-sized data structure (40) in the secondary storage (16),

said entries including the identifier (36) that uniquely identifies the second
set of logically contiguous file data; 
means (12, 24) for storing a second identifier (44) in the second variable-sized
data structure (40) that uniquely identifies the second variable-sized

data structure (40) within a fixed-sized data structure (Buckets 1 to N);
means (12, 24) for storing the second variable-sized data structure (40) in
the fixed-sized data structure (Buckets 1 to N) wherein the first variable-sized

data structure (40) is stored; and
means for storing in the map (74) the identifier (44) that uniquely identifies
the second variable-sized data structure (40).
The data processing system (10) of claim 16 or 17 wherein the secondary
storage (16) is disk storage.
The data processing system (10) of one of claims 16 to 18, further comprising:

means (12, 24) for storing property information (42, 44, 46, 48, 50, 58, 60,
62, 64, 66, 68, 70) about the first variable-sized data structure (40) in the

secondary storage (40).
The data processing system (10) of claim 19, further comprising:

means (12, 24) for querying the first variable-sized data structure (40) to
obtain the property information (42, 44, 46, 48, 50, 58, 60, 62, 64, 66, 68,

70) stored therein.
A computer-readable medium comprising computer-executable instructions
adapted to enable the data processing system (10) to perform the method as

claimed in one of claims 1 to 15.
</CLAIMS>
</TEXT>
</DOC>
