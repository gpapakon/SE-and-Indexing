<DOC>
<DOCNO>EP-0613084</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Data processing system.
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F9445	G06F9445	G06F1208	G06F1208	G06F1210	G06F1210	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F9	G06F12	G06F12	G06F12	G06F12	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
Lazy loading of executable library objects reduces operating system 
overhead and memory commitment requirements by postponing object loading 

until object references are expected. Initial task loading allocates 
only the main executable and library objects referenced by that 

executable. Secondary referenced objects are not allocated. Object 
references cause page faults for allocated but not loaded pages. Page 

fault handling causes loading and fixup of executable objects. Page 
fault handling also determines the next level of object references and 

allocates memory for the next object level. Shared memory systems allow 
sharing of executable objects until explicitly referenced. Once 

referenced, memory fault causes copying and fixup to referencing task 
memory area. 


</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
IBM
</APPLICANT-NAME>
<APPLICANT-NAME>
INTERNATIONAL BUSINESS MACHINES CORPORATION
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
ARENDT JAMES WENDELL
</INVENTOR-NAME>
<INVENTOR-NAME>
GIANGARRA PAUL PLACIDO
</INVENTOR-NAME>
<INVENTOR-NAME>
MANIKUNDALAM RAVINDRANATH KASI
</INVENTOR-NAME>
<INVENTOR-NAME>
PADQETT DONALD ROBERT
</INVENTOR-NAME>
<INVENTOR-NAME>
PHELAN JAMES MICHAEL
</INVENTOR-NAME>
<INVENTOR-NAME>
ARENDT, JAMES WENDELL
</INVENTOR-NAME>
<INVENTOR-NAME>
GIANGARRA, PAUL PLACIDO
</INVENTOR-NAME>
<INVENTOR-NAME>
MANIKUNDALAM, RAVINDRANATH KASINATH
</INVENTOR-NAME>
<INVENTOR-NAME>
PADQETT, DONALD ROBERT
</INVENTOR-NAME>
<INVENTOR-NAME>
PHELAN, JAMES MICHAEL
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to information processing systems and 
more particularly to operating systems. Still more particularly, this 
invention relates to systems for controlling the loading of executable 
tasks by an operating system. Computer operating systems control the operation of computer system 
components. Among the responsibilities of the operating system is 
loading other programs for execution. The other programs are typically 
application programs, but also may include operating system components. 
Loading programs involves finding the requested program on the program 
storage media, typically a hard disk file, and then bringing the program 
into memory and making it ready to be executed by the processor. Programs are stored in program storage in executable form that 
results from compilation or assembly of program source code. The 
executable form of the program has a specified format known to the loader 
that contains information necessary for processing that executable code. 
One of the processing steps the loader performs is address relocation. 
Addresses in the executable file are expressed relative to a beginning 
address. This beginning address or starting offset is not determined 
until the program is loaded into memory. Address relocation modifies the 
relative addresses so that they point to actual addressable locations in 
the system. Once the addresses have been fixed, the program is ready to 
execute. Computer programs have become increasingly complex as system user 
requirements have expanded and as the capabilities of systems have 
increased. The increased capacity of microcomputer systems such as the 
IBM PS/2 computer system (PS/2 is a trademark of the IBM Corporation) is 
one example. Increased processor capacity and function has allowed 
complex word processing, spread sheet, database, and other business and 
scientific applications to be developed. Complex applications, however, 
result in increasingly larger executable files. The generation of large executable files whenever a portion of an 
application or system changed increases the cost and time required to 
create or revise an application or system. One solution to this problem 
has been to divide applications or systems into segments that are  
 
dynamically loadable. Linking (address resolution) of these segments is 
deferred until execution time. Each segment is defined to contain a 
specific portion of code and is written to respond to well defined 
interfaces. Programs in other segments that access a
</DESCRIPTION>
<CLAIMS>
A data processing system for managing allocation of memory to 
executable programs, the system comprising: 

   means for receiving a request to load a primary executable program 
into memory; 

   means for determining secondary executable programs referenced by 
said primary executable program; 

   means for allocating memory slots to said secondary executable 
programs without loading said programs into memory; 

   means for detecting references to one of said allocated but 
unloaded slots, said means for detecting generating a detect signal when 

a reference is detected; and 
   means for loading the executable program allocated said slot into 

memory in response to said detect signal. 
A system as claimed in claim 1 wherein said means for loading the 
executable program comprises: 

   means for copying said executable program from a storage device; 
   means for relocating address references in said executable program; 

   means for determining executable programs referenced by said 
executable program; and 

   means for allocating memory slot to said referenced executable 
programs without loading said programs into memory. 
A system as claimed in claim 2, wherein said means for detecting is 
a page fault detection system. 
A system as claimed in any preceding claim, wherein said means for 
loading is an external pager. 
A method for dynamically loading executable routines in a data 
processing comprising the steps of: 

   receiving a request to load a main executable routine into memory; 
   creating a list of all routines referenced by said main executable 

routine; 
   allocating memory locations to said routines without loading said 

routines; 
   detecting a reference to one of said allocated memory locations and 

generating a detection signal; and 
   loading said routine into said allocated memory location in 

response to said detection signal. 
A method as claimed in claim 5 wherein said loading step includes 
the steps of: 

   copying said routine from a storage device; 
   relocating address references in said routine; 

   creating a list of routines referenced by said loaded routine; and 
allocating memory locations to said referenced routines without 

loading said routines into memory. 
A method as claimed in claim 5 or claim 6, wherein said detecting 
step includes detecting a memory page fault reference. 
A method as claimed in any of claims 5 to 7, wherein said loading 
step includes passing control to an external pager to perform said 

loading steps. 
</CLAIMS>
</TEXT>
</DOC>
