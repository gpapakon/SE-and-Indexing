<DOC>
<DOCNO>EP-0639926</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Method and apparatus for motion vector estimation using block matching.
</INVENTION-TITLE>
<CLASSIFICATIONS>G06T720	G06T720	H04N514	H04N514	H04N726	H04N726	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06T	G06T	H04N	H04N	H04N	H04N	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06T7	G06T7	H04N5	H04N5	H04N7	H04N7	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
For many applications it is necessary to be able to estimate the velocity of objects 
in a television signal over a large range of velocities. The signal processing to 

perform this task, e.g. block matching, requires often large and expensive hardware 
implementations. In consumer applications, the cost of providing an estimate 

of velocities over a very large range is prohibitively high. As block matching is 
computationally intensive, real-time hardware implementations of this technique 

implement some form of parallel processing. The most common form is to have 
one block matching processor per candidate motion vector.

 
To reduce the computa
tional power, one solution is to cover the same numerical 
range of motion, but with decreased accuracy. Another solution is to limit the 

search range at some maximum value. Combinations of both methods can be 
used. The cost and complexity of such a system can also be reduced by providing 

a non-uniform measurement of possible motion vectors. 

</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
THOMSON CONSUMER ELECTRONICS
</APPLICANT-NAME>
<APPLICANT-NAME>
THOMSON CONSUMER ELECTRONICS (S.A.)
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
BOLENDER NADINE
</INVENTOR-NAME>
<INVENTOR-NAME>
HACKETT ANDREW
</INVENTOR-NAME>
<INVENTOR-NAME>
KENDRANVAT MICHEL
</INVENTOR-NAME>
<INVENTOR-NAME>
KNEE MICHAEL
</INVENTOR-NAME>
<INVENTOR-NAME>
BOLENDER, NADINE
</INVENTOR-NAME>
<INVENTOR-NAME>
HACKETT, ANDREW
</INVENTOR-NAME>
<INVENTOR-NAME>
KENDRANVAT, MICHEL
</INVENTOR-NAME>
<INVENTOR-NAME>
KNEE, MICHAEL
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates to a method for motion vector estimation 
using block matching. Block matching is a well known technique for the estimation of 
motion in television pictures. Such a technique finds application 
in diverse areas such as standards conversion (for example, 
50Hz to 60Hz), bit rate reduction coding and display rate upconversion. 
For most applications, it is necessary to be able to 
estimate the velocity of objects in the television signal over a 
large range of velocities. The signal processing required to 
perform this task is quite high, and this often results in large 
and expensive hardware implementations. In consumer applications, 
the cost of providing an estimate of velocities over a 
very large range is prohibitively high. It is one object of the invention to disclose a method reducing 
the amount of hardware required for performing motion vector 
measurement. This object is reached by the method disclosed in 
claim 1. Typically, in a block matching motion estimation system as 
depicted in Fig. 1, the current field or frame CF of the picture 
is divided into rectangular blocks. For each current 
block, a search is made over overlapping blocks within a 
search window SW in the previous field or frame PF to find 
the one that matches the current field block CF the best according 
to some criterion, typically mean-square or mean absolute 
error. The relative position of the two blocks gives 
the displacement, or motion, vector MV for the current block  
 
CB. This principle holds whether single or double sided block 
matching is used. The advantages of double sided block matching 
are described in another patent application (internal 
ref. D93/067I) of the applicant. The motion vectors can e.g. 
be used for calculating an interpolated field IP. As block matching is computationally intensive, real-time hardware 
implementations of this technique implement some form of 
parallel processing. The most common form is to have one block 
matching processor per candidate motion vector. 
The cost and complexity of such a system can be reduced by 
providing a non-uniform measurement of possible motion vectors. In principle, the inventive method is suited for motion vector 
estimation using block matching by calculating said motion 
vector using a non-uniform measurement of candidate motion 
vectors within a related search window.
 
Advantageously, the accuracy of said measurement is made non-uniform 
within said search window by dividing the window into, 
at minimum, an area of
</DESCRIPTION>
<CLAIMS>
Method for motion vector estimation using block matching, 
characterised in calculating said motion vector (MV) using a 

non-uniform measurement of candidate motion vectors within a 
related search window (SW). 
Method according to claim 1, characterised in that the accuracy 
of said measurement is made non-uniform within said 

search window (SW) by dividing the window into, at minimum, an 
area of high precision (AHP) and an area of low precision 

(ALP), wherein the density of the used pixel values of the 
input signal for said motion vector calculation is less than 

in said area of high precision. 
Method according to claim 1 or 2, characterised in that said 
search window (SW) is rectangular and includes one or more 

uncompensated regions (UCR), in particular in diagonal direction. 
Method according to any of claims 1 to 3, characterised in 
that a double-sided block matching is used to calculate said 

motion vector (MV). 
Method according to any of claims 1 to 4, characterised in 
that the height and the width of said search window (SW), or 

areas, are different. 
Method according to any of claims 1, 4 or 5, characterised in 
that the accuracy of said measurement is made non-uniform 

within said search window (SW) by reducing the density of the 
used pixel values of the input signal for said motion vector 

calculation. 
Method according to any of claims 1 to 6, characterised in 
that said motion vector estimation is made for standards conversion, 

bit rate reduction coding and/or display rate upconversion. 
</CLAIMS>
</TEXT>
</DOC>
