<DOC>
<DOCNO>EP-0614137</DOCNO> 
<TEXT>
<INVENTION-TITLE>
Data processing system providing an extensible register and method thereof
</INVENTION-TITLE>
<CLASSIFICATIONS>G06F930	G06F1202	G06F934	G06F934	G06F9318	G06F1202	G06F9355	G06F9318	G06F930	</CLASSIFICATIONS>
<CLASSIFICATIONS-THIRD>G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	G06F	</CLASSIFICATIONS-THIRD>
<CLASSIFICATIONS-FOURTH>G06F9	G06F12	G06F9	G06F9	G06F9	G06F12	G06F9	G06F9	G06F9	</CLASSIFICATIONS-FOURTH>
<ABSTRACT>
A data processing system providing an extensible register 
and method thereof. A new CPU (12) has an extensible index 

register (304). The new CPU (12) is object code compatible with 
the old CPU having an 8-bit index register (302), yet the index 

register (304) of the new CPU (12) can be effectively extended to 
16 bits when new instructions are used. As a consequence, the 

user is able to make the choice between using assembly code 
software written for the old CPU and having the functionality of 

an 8-bit index register, or writing new assembly code software 
for the new CPU (12) and having the functionality of a 16-bit 

index register. 

 
</ABSTRACT>
<APPLICANTS>
<APPLICANT-NAME>
MOTOROLA INC
</APPLICANT-NAME>
<APPLICANT-NAME>
MOTOROLA, INC.
</APPLICANT-NAME>
</APPLICANTS>
<INVENTORS>
<INVENTOR-NAME>
CATHERWOOD MICHAEL I
</INVENTOR-NAME>
<INVENTOR-NAME>
DIVINE JAMES S
</INVENTOR-NAME>
<INVENTOR-NAME>
STUDOR CHARLES F
</INVENTOR-NAME>
<INVENTOR-NAME>
CATHERWOOD, MICHAEL I.
</INVENTOR-NAME>
<INVENTOR-NAME>
DIVINE, JAMES S.
</INVENTOR-NAME>
<INVENTOR-NAME>
STUDOR, CHARLES F.
</INVENTOR-NAME>
</INVENTORS>
<DESCRIPTION>
The present invention relates in general to a data 
processing system, and more particularly to a data processing 
system providing an extensible register and method thereof. A central processing unit (CPU) is generally the primary 
"brain" of a microcontroller integrated circuit (MCU). Aside from 
the CPU, an MCU normally includes one or more on-board 
peripherals or sections, such as memories, timers, and bus 
interfaces. The CPU however, is usually responsible for receiving 
and interpreting the software instructions used to control the 
MCU. One particular CPU may be used on a variety of MCUs. If the 
same CPU is used on a variety of MCUs, these MCUs are generally 
considered to form a "family" (such as the MC68HC05 family of 
microcontrollers, available from Motorola, Inc. of Austin, Texas). 
There are many advantages to using the same CPU on a variety of 
MCUs, both from the manufacturer's point of view and from the 
customer's point of view. One such advantage is software 
compatibility among MCUs in a family which uses the same CPU. However, a problem arises when a new and more powerful 
version of the CPU is desired. One of the key decisions that must 
be made when designing a new and more powerful version of a CPU 
is determining whether or not to maintain "object code 
compatibility" with the old CPU. As it is being used in this 
document, the term "object code compatible" is an all or nothing 
characteristic of the new CPU. That is, either the new CPU is 
capable of running assembly language software written for the 
old CPU (and producing the same results), or it is not. Thus any 
differences between the old CPU and the new CPU must be 
completely transparent to an assembly language software 
program written for the old CPU.  
 There is a very significant advantage to designing a new 
CPU so that it is object code compatible with the old CPU. The 
advantage is that the software that has been written for the old 
CPU can immediately be used for the new CPU. Thus customers 
who had been buying and using the old CPU can simply switch to 
using the new, more powerful CPU. And customers are assured 
that the software they were using with the old CPU will also 
work with the new CPU. Thus, there is no cost to the customer in 
having to modify or rewrite software in order to upgrade to a 
more powerful CPU. Designing a new and more powerful CPU that 
is object code compatible with an old CPU allows customers to 
upgrade to a more powerful CPU without having to incur the costs 
and risks associated
</DESCRIPTION>
<CLAIMS>
A data processing system (10) which can be extended from a 
first instruction set of a previously existing data 

processing system to a second instruction set, the second 
instruction set including instructions of the first 

instruction set, the data processing system having registers 
which can be widened to extend the bit size for the purpose 

of maintaining object code compatibility between the first 
instruction set and the second instruction set, the data 

processing system (10) further characterized by: 

a register (304) having a first register portion (212) 
which is alterable by instructions of both the 

first instruction set and the second instruction 
set, the register (304) having a second register 

portion (205) which is alterable only by 
instructions of the second instruction set and 

not by instructions of the first instruction set, 
the second register portion having a stored value 

which is not modified by any instructions of the 
first instruction set regardless of type of 

instruction; and 
address generation circuitry (204, 216, 202, 224, 214, 
218, 232, 238, 234, 240) coupled to the register 

(304), the address generation circuitry (204, 

216, 202, 224, 214, 218, 232, 238, 234, 240) 
using a combination of the first register portion 

(212) and the second register portion (205) in 
order to generate an address when the data 

processing system (10) is performing an 
addressing operation. 
The data processing system (10) of claim 1 further 
characterized by said address generation circuitry (204, 

216, 202, 224, 214, 218, 232, 238. 234. 240) performs a 
concatenation of the first register portion and the second 

register portion to generate the address.  
 
The data processing system (10) of claim 1 further 
characterized by circuitry (62) which resets the second 

register portion (205) to a zero value when the data 
processing system (10) is reset. 
The data processing system (10) of claim 1 further 
characterized by the data processing system (10) being 

object code compatible with a known previously existing 
data processing system. 
The data processing system (10) of claim 4 wherein a first 
instruction of the first instruction set is further 

characterized by having a first opcode which is identical to 
a first known opcode used in the previously existing data 

processing system, and a second instruction which is an 
instruction of the second instruction set is further 

characterized by having a second opcode which is undefined 
by the previously existing data processing system. 
A method of extending a first instruction set of a previously 
existing data processing system to a second instruction set 

for use in a data processing system (10), the second 
instruction set including instructions of the first 

instruction set, the data processing system (10) having 
registers which can be widened to extend the bit size for 

the purpose of maintaining object code compatibility 
between the first instruction set and the second instruction 

set, the method further characterized 
by the steps of: 


altering a first register portion (212) of a register 
(304) by instructions of both the first 

instruction set and the second instruction set; 
altering a second register portion (205) of the 
register (304) only by instructions of the second 

instruction set and not by instructions of the 
first instruction set, the second register portion  

 
having a stored value which is not modified by 

any instructions of the first instruction set 
regardless of type of instruction; and 
coupling address generation circuitry (204, 216, 202, 
224, 214, 218, 232, 238, 234, 240) to the 

register (304) in order to generate an address 
when the data processing system (10) is 

performing an addressing operation, the address 
generation circuitry (204, 216, 202, 224, 214, 

218, 232, 238, 234, 240) using a combination of 
the first register portion (212) and the second 

register portion (205) to provide the address. 
The method of claim 6, further comprising the steps of:
 
   using a concatenation of the first register portion and 

the second register portion as the combination 
of the first register portion and second register 

portion to provide the address. 
The method of claim 6, further comprising the steps of:
 
   resetting the second register portion (205) to a zero 

value when the data processing system (10) is 
reset. 
The method of claim 6, further comprising the steps of:
 
   generating an effective address as the address. 
</CLAIMS>
</TEXT>
</DOC>
